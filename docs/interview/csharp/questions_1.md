---
outline: deep
---
# C# 基础面试题（一）
## 引言
本文汇集了众多C#面试题，涵盖了C#的基础知识、高级特性、常见问题等方面。这些面试题不仅可以帮助您准备C#相关的面试，也可以帮助您巩固和提升您的C#编程技能。无论您是一个C#初学者，还是一个C#高手，您都可以从这些面试题中学到一些新的知识和经验。

在这些面试题中，将按照不同的模块进行了划分

 - 面试题一：汇集了C# 基础概念与常识、对象和类基础、语法基础、方法基础
 - 面试题二：汇集了C# 面对对象基础、委托与事件、String、数组、常用类库以及Linq
 - 面试题三：汇集了C# 泛型、反射、I/O、序列化、垃圾回收、异常、多线程

## 基础概念与常识
### 什么是C#？
C#是一种计算机编程语言。微软在2000年开发了C#，以提供一种现代通用编程语言，可用于开发针对各种平台（包括Windows，Web和Mobile）的各种软件。今天，C#是世界上最受欢迎的编程语言之一。数以百万计的软件开发人员使用 C#构建各种软件。

C#是构建 Microsoft .NET 软件应用程序的主要语言。开发人员可以使用 C#构建几乎所有类型的软件，包括 Windows UI 应用、控制台应用、后端服务、云 API、Web services、控件和库、serverless应用程序、Web 应用程序、native iOS 和 Android 应用、AI 和机器学习软件以及区块链应用程序。

C#是一种面向对象和类型安全的编程语言。这表明程序在编写时就会捕获错误，避免了以后浪费时间修复小问题。它使用.Net框架编译，生成Microsoft Intermediate Language（MSIL），这是一种可以在多种环境下运行的指令集。C#的最新版本是C# 11。

### 列举一些C#的主要特点
 - 简单的语言：没有指针或直接内存修改，与C++或C相比
 - 类型安全：确保变量的数据类型正确定义
 - 面向对象：可以定义和使用类/对象
 - 面向组件：可以重用现有的组件，而无需从头编码
 - 开源：可以在多种操作系统上开发应用，包括Mac和Linux
 - 互操作性：可以使用管理和非管理的第三方代码开发
 - 结构化编程：可以将程序分解为函数
 - 丰富的库：内置的函数加速了开发
 - 快速：编译和执行都非常快

### CTS、CLS、CLR分别作何解释

**CTS**：Common Type System通用类型系统。`Int32`、`Int16→int`、`String→string`、`Boolean→bool`。每种语言都定义了自己的类型，.NET通过CTS提供了公共的类型，然后翻译生成对应的.NET类型

**CLS**：Common Language Specification通用语言规范。不同语言语法的不同。每种语言都有自己的语法，.NET通过CLS提供了公共的语法，然后不同语言翻译生成对应的.NET语法

**CLR**：Common Language Runtime公共语言运行时，就是GC、JIT等这些。有不同的CLR，比如服务器CLR、LinuxCLR（Mono）、SilverlightCLR(CoreCLR)。相当于一个发动机，负责执行IL。

### 什么是托管代码或非托管代码？

**托管代码**：托管代码是由公共语言运行时（CLR）执行的代码。.Net框架使用垃圾回收器（Garbage collector）在内部清理不需要的内存，因此称为托管代码。

**非托管代码**：非托管代码是由.Net运行时以外的框架执行的代码，或者在.Net框架之外执行的代码。非托管代码是直接运行在操作系统上，不受 CLR 管理和约束的代码，例如 C 或 C++ 代码。

### 简述C#成员修饰符

**public**：公共成员，完全公开，没有访问限制

**private**：私有成员，在类的内部才可以访问

**protected**：保护成员，在该类内部和继承类中可以访问

**internal**：在同一程序集内可以访问

**protected internal**：在同一程序集或者继承类中可以访问

**static**：静态成员，在类级别上定义，在类加载时分配内存空间

**const**：常量成员，在编译时确定值，并且不能修改

**readonly**：只读成员，在运行时确定值，并且只能在构造函数中修改

**sealed**：密封成员，在派生类中不能被重写

**abstract**：抽象成员，在抽象类中定义，并且必须在子类中实现

**virtual**：虚成员，在基类中定义，并且可以在子类中重写

**override**：重写成员，在子类中重写基类中定义的虚成员或者抽象成员

**new**：隐藏成员，在派生类中定义一个与基类同名同参的方法，隐藏掉基类方法

### file访问修饰符是什么
file 访问修饰符可以用来修饰类、结构或接口，使它们的可见范围仅限于声明它们的文件。这样做的好处是可以避免在同一个命名空间或程序集中生成的类型之间发生名称冲突，特别是对于源代码生成器来说很有用。

file 访问修饰符的使用方法是在类型声明前加上 file 关键字，例如 `file class HiddenWidget`。这样，这个类就只能在同一个文件中被访问，其他文件中的代码无法看到它。如果在其他文件中声明了同名的类型，也不会产生冲突。

### C#代码编译的四个步骤
包括:
 - 预处理：预处理器将源代码中的指令（如 #define 和 #include）进行处理，生成预处理后的代码文件。
 - 编译：编译器将预处理后的代码文件转换为中间语言（IL）代码文件，也称为元数据文件或程序集文件，扩展名为 .dll 或 .exe。
 - 链接：链接器将编译后的代码文件与所需的库文件和资源文件进行链接，生成最终的可执行文件。
 - 执行：执行器（如 CLR 或 .NET Core 运行时）将可执行文件加载到内存中，并通过即时编译（JIT）或预先编译（AOT）将 IL 代码转换为本地机器码，然后运行程序。

### C# 中堆和栈的区别？

栈：由编译器自动分配、释放。在函数体中定义的变量通常在栈上。

堆：一般由程序员分配释放。用`new`、`malloc`等分配内存函数分配得到的就是在堆上。存放在栈中时要管存储顺序，保持着先进后出的原则，他是一片连续的内存域，有系统自动分配和维护；

堆是无序的，他是一片不连续的内存域，有用户自己来控制和释放，如果用户自己不释放的话，当内存达到一定的特定值时，通过垃圾回收器(GC)来回收。

栈内存无需我们管理，也不受GC管理。当栈顶元素使用完毕，立马释放。而堆则需要GC清理。使用引用类型的时候，一般是对指针进行的操作而非引用类型对象本身。但是值类型则操作其本身。

### C# 中的命名空间是什么？它有哪些作用？
命名空间是一种特殊类型，用于定义一组相关的类型和成员，并且避免命名冲突。命名空间有以下作用：

 - 命名空间提供了代码组织和管理的能力，并且遵循层次结构
 - 命名空间可以使用using指令或完全限定名称来引用或访问

### 什么叫应用程序域(AppDomain)

应用程序域是一个进程中的逻辑分区，它提供了一个隔离的环境，可以在其中执行托管代码。应用程序域可以实现多个应用程序在同一个进程中运行而不相互影响，也可以实现应用程序的动态加载和卸载

### c# 可否对内存直接操作

c# 可以使用unsafe关键字来对内存直接操作，但是这样做会破坏c#的类型安全和内存管理机制。

### C# 中什么是控制台应用程序？
控制台应用程序是一种在命令行窗口中运行和交互的应用程序，它通常用于执行简单的任务或测试代码。

### 什么是WebService?

WebService是一种基于Web的服务交互技术，它可以让不同平台、不同语言的应用程序之间进行通信和数据交换 。WebService通常使用SOAP协议、WSDL描述语言和UDDI注册中心来实现 。

## 对象和类基础

### C# 中类是什么？

类是一种概念，用于定义数据在程序中如何结构化、存储和管理。类有属性和方法，称为类成员。这些成员可以是私有的，也就是说它们只能被类访问，或者是公共的，也就是说它们允许程序的其他部分访问它们。

### C# 中结构体是什么？
结构体是一种特殊类型，用于表示一组相关的数据成员。

### C# 中的结构和类有什么区别？
结构体与类有以下区别：
 - 结构体是值类型，类是引用类型
 - 结构体在栈上分配内存，类在堆上分配内存
 - 结构体不能继承其他结构体或类，类可以继承其他类
 - 结构体不能声明默认的无参构造函数，类可以
 - 结构体适合表示轻量级的数据结构，类适合表示复杂的业务逻辑

### C#10 中struct有什么改进？
有以下改进：
 - struct类型支持声明无参构造函数。**在C#10之前是不能有无参构造函数的。**
 - with表达式的左操作数可以是任何struct类型或匿名（引用）类型。

### C# 中构造函数是什么？
构造函数是一种特殊的方法，用于初始化类的对象。构造函数与类同名，并且没有返回类型。构造函数可以有不同的参数列表，称为构造函数重载。

### C# 中的Constructor Chaining是什么？
Constructor Chaining是一种将两个或多个类连接为继承关系的方法。在Constructor Chaining中，每个子类的`Constructor`都通过`base`关键字隐式映射到一个父类的`Constructor`，所以当创建子类的实例时，它会调用父类的`Constructor`。如果没有它，继承是不可能实现的。

### C# 中静态构造函数特点是什么？

最先被执行的构造函数，且在一个类里只允许有一个无参的静态构造函数

执行顺序：静态变量>静态构造函数>实例变量>实例构造函数。

### C# 中的属性是什么？它有什么作用？

属性是一种特殊的成员，用于封装类中字段（变量）的访问。属性提供了一个get访问器和一个set访问器来读取和写入字段值。属性可以提供数据验证、计算或转换等逻辑，并且可以使字段对外部代码可见或隐藏。

### C# 中的索引器是什么？它有什么作用？

索引器是一种特殊成员，用于允许按照索引访问类中集合或数组类型字段中元素。索引器提供了一个get访问器和一个set访问器来读取和写入元素值。索引器使用this关键字来定义，并且可以有多个参数。

### C# 中什么是值类型与引用类型？

值类型：`struct`、`enum`、`int`、`float`、`char`、`bool`、`decimal`。

引用类型：`class`、`delegate`、`interface`、`array`、`object`、`string`

### C# 中的枚举是什么？它有哪些特点？
枚举是一种特殊类型，用于定义一组命名的常量值。枚举可以提高代码的可读性和可维护性，并且可以避免使用数字。枚举的基础类型默认是int，但也可以是byte、sbyte、short、ushort、uint、long或ulong。

### C# 中int?和int有什么区别？

`int?`为可空类型，默认值可以是`null`

`int`默认值是0；

`int?`是通过`int`装箱为引用类型实现

### C# 中什么是装箱和拆箱？

装箱和拆箱都用于类型转换

**装箱**：把值类型转换为引用类型。装箱是一种隐式转换。装箱是对值类型在堆中分配一个对象实例，并将该值复制到新的对象中，例如：

```C#
int num = 123;
Object obj = num;
Console.WriteLine(num);
Console.WriteLine(obj);
```

**拆箱**：把引用类型转换成值类型。拆箱会检查对象的实际类型是否与指定的目标类型兼容，如果兼容，则返回该对象中包含的值。例如：

```C#
Object obj2 = 123;
int num2 = (int)obj2;
Console.WriteLine(num2);
Console.WriteLine(obj2);
```

### C# 中的元组是什么？
C# 中的元组是一种使用轻量语法定义的类型，可以将多个数据元素分组成一个轻型数据结构。元组可以使用小括号和逗号来声明和初始化，例如 (1, 2, 3) 或 (name: “Alice”, age: 25) 。

元组可以用于作为方法返回类型，或者代替匿名类型。元组是值类型，元组元素是公共字段，可以使用 Item1, Item2, Item3 等默认名称或自定义名称来访问。

### C# 中的匿名类型是什么？
匿名类型允许在不定义它们的情况下创建新类型。这是一种在单个对象中定义只读属性而无需显式定义每种类型的方法。在这里，Type由编译器生成，并且只能为当前代码块访问。属性的类型也由编译器推断。

### C# 中的partial类是什么？ 为什么需要partial类？

partial类可以一个类将拆分为两个或多个源文件。这些文件将在运行时被编译为一个类。而且当创建此类类的实例时可以使用同一对象访问所有源文件中的所有方法。

### C# 中的 record 类型是什么？
record 类型是一种新的引用类型或值类型，它可以用来创建不可变的对象，支持基于值的相等性和非破坏性修改。可以使用`record class` 或 `record struct` 来指定是引用类型还是值类型。

record 类型会自动生成一些方法，如 Equals、GetHashCode、ToString、Clone 等，以便实现基于值的相等性和复制功能。

record 类型适合用来表示不可变的数据模型，如 DTO、POCO 等，可以提高代码的简洁性和可读性。
### 什么是强类型，什么是弱类型？哪种更好些？为什么?

强类型是指变量的类型一旦定义就不能改变，并且只能与同类型或兼容类型的变量进行操作；弱类型是指变量的类型可以随时改变，并且可以与任意类型的变量进行操作。强类型更好些，因为它可以避免一些潜在的错误，并且提高代码的可读性和可维护性。

## 语法基础

### C# 中static关键字的作用？

对类有意义的字段和方法使用static关键字修饰，称为静态成员，通过类名加访问操作符“.”进行访问; 对
类的实例有意义的字段和方法不加static关键字，称为非静态成员或实例成员。

注: 静态字段在内存中只有一个拷贝，非静态字段则是在每个实例对象中拥有一个拷贝。而方法无论是否
为静态，在内存中只会有一份拷贝，区别只是通过类名来访问还是通过实例名来访问。

### C# 成员变量和成员函数前加static的作用？

它们被称为常成员变量和常成员函数，又称为类成员变量和类成员函数。

分别用来反映类的状态。

比如类成员变量可以用来统计类实例的数量，类成员函数

负责这种统计的动作。不用new

### C#中的“continue”和“break”语句有什么区别？

使用 break 语句，可以“跳出循环”，而使用 continue 语句，可以“跳过一次迭代”并恢复循环执行。

**break示例**
```C#
using System;
using System.Collections;
using System.Linq;
using System.Text;
namespace break_example {
    Class brk_stmt {
        public static void main(String[] args) {
            for (int i = 0; i <= 5; i++) {
                if (i == 4) {
                    break;
                }
                Console.WriteLine("The number is " + i);
                Console.ReadLine();
            }
        }
    }
}
```

**输出**

The number is 0; 

The number is 1; 

The number is 2; 

The number is 3;

**Continue示例**
```C#
using System;
using System.Collections;
using System.Linq;
using System.Text;
namespace continue_example {
Class cntnu_stmt {
public static void main(String[] {
        for (int i = 0; i <= 5; i++) {
            if (i == 4) {
                continue;
            }
            Console.WriteLine("The number is "+ i);
                Console.ReadLine();
            }
        }
    }
}
```

**输出**

The number is 1;

The number is 2;

The number is 3;

The number is 5;

### const和readonly有什么区别？

`const` 和`readonly`都可以用来修饰常量，但是有以下区别：

`const`修饰的常量必须在声明的同时赋值，并且不能修改；

`readonly`修饰的常量可以在声明时或者构造函数中赋值，并且只能在构造函数中修改；

`const`修饰的常量是编译时常量，它会被编译器替换为实际的值；

`readonly`修饰的常量是运行时常量，它会被编译器存储在元数据中。

### 什么是转义序列？在C#中有哪些转义序列？

转义序列是用反斜杠（`\`）表示的字符序列，用于表示一些特殊字符或格式控制符。在C#中有以下转义序列：
 - `\n`：换行符
 - `\t`：制表符
 - `\r`：回车符
 - `\b`：退格符
 - `\f`：换页符
 - `\\`：反斜杠
 - `\'`：单引号
 - `\"`：双引号



### C# 中相等运算符 (==) 和 Equals() 方法的区别
`==` 运算符和 `Equals()` 方法比较两个值类型数据或引用类型数据。相等运算符 (==) 是比较运算符，Equals() 方法比较字符串的内容。`==`运算符比较引用指针，而 `Equals()` 方法只比较内容。

### &和&&，|和||有什么区别？

&和|是按位运算符，它们会对两个操作数的每一位进行逻辑运算；&&和||是逻辑运算符，它们会对两个操作数进行逻辑运算。&和&&都表示逻辑与运算，但是&不管前面的条件是否成立，后面的条件依旧会判断；而&&如果前面的条件不成立，后面的条件就不会判断。|和||都表示逻辑或运算，但是|不管前面的条件是否成立，后面的条件依旧会判断；而||如果前面的条件成立，后面的条件就不会判断。

### i++和++i有什么区别？

i++表示先使用i的值再自增1；++i表示先自增1再使用i的值。

### 分析下面代码，a、b的值是多少？

```C#
int a = 10;
int b= a++;
a = ++b;
```

a的值是12，b的值是11。

因为a++是先赋值后自增，所以b等于10，然后a等于11

而++b是先自增后赋值，所以b等于11，然后a等于12

### as和is的区别

as和is都是用来进行类型转换或者类型检查的运算符。as用来将一个对象转换为另一个类型，并且如果转换失败则返回null；is用来检查一个对象是否为另一个类型，并且返回一个布尔值。

### 在C#中如何使用“using”语句？
在 C# 中有两种使用 using 关键字的方法。一个是指令，另一个是声明。

using 指令
通常，在代码隐藏和类文件中使用 using 关键字来添加命名空间。然后它使当前页面上的所有类、接口和抽象类及其方法和属性可用。

using 语句
这是在 C# 中使用 using 关键字的另一种方法。它在提高垃圾收集性能方面起着至关重要的作用。

### new关键字的作用

运算符：创建对象实例

修饰符：在派生类定义一个重名的方法，隐藏掉基类方法

约束：泛型约束定义，约束可使用的泛型类型

### 谈谈final、finally的区别

final是一个修饰符，它可以用来修饰类、方法、字段等，表示不可继承、不可重写、不可修改

finally是一个语句块，它通常与try-catch语句一起使用，表示无论是否发生异常都要执行的代码。



### 列举你知道的数字格式化转换

数字格式化转换有：

**C或者c**：表示货币格式，如123.456c输出￥123.46

**D或者d**：表示十进制格式，如123d输出123

**E或者e**：表示科学计数法格式，如123e输出1.23E+002

**F或者f**：表示固定点格式，如123.456f输出123.46

**G或者g**：表示常规格式，如123.456g输出123.456

**N或者n**：表示数字格式，如123456.789n输出123，456.79

**P或者p**：表示百分比格式，如0.123p输出12.30%

**R或者r**：表示往返格式，保证数值转换为字符串再转换回来不会丢失精度

**X或者x**：表示十六进制格式，如255x输出FF 


## 方法

### C#中参数传递ref与out的区别?

`ref`指定的参数在函数调用时必须先初始化，而`out`不用

`out`指定的参数在进入函数时会清空自己，因此必须在函数内部进行初始化赋值操作，而`ref`不用

`ref`可以把值传到方法里，也可以把值传到方法外；`out`只可以把值传到方法外

### “this”可以在静态方法中使用吗？

不能在静态方法中使用“this”，因为关键字“this”返回对包含它的类的当前实例的引用。

静态方法（或任何静态成员）不属于特定实例。因为它们不能创建类的实例，并且它们是使用类名调用的。因此不能在静态方法中使用 this 关键字。但是

它们在不创建类实例的情况下存在，并且使用类名而不是实例调用，因此我们不能在静态方法的主体中使用 this 关键字。 但是，在扩展方法的情况下，我们可以使用方法的参数。

### 什么是扩展方法？

扩展方法是一种特殊的静态方法，它可以为已有的类型添加新的功能而无需修改原有代码或者继承该类型。扩展方法需要定义在静态类中，并且使用`this`关键字修饰第一个参数，该参数表示要扩展的类型。

### 参数传递有哪几种方法？
参数传递的方法包括：
 - 按值传递：就是将变量副本传递给方法。方法对参数的任何修改都不会影响原始变量的值。这是默认的参数传递方式。
 - 按引用传递：就是将对变量的访问传递给方法。方法对参数的任何修改都会影响原始变量的值。要使用这种方式，必须在方法定义和调用时都使用 ref 关键字。
 - 输出传递：就是将未初始化的变量传递给方法，方法必须为参数赋值，并将结果返回给调用方。要使用这种方式，必须在方法定义和调用时都使用 out 关键字。