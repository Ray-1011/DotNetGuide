---
outline: deep
---
# C# 基础面试题（三）

## 泛型、反射

### C# 中的泛型是什么？它有什么作用？
泛型是一种特殊类型或方法，在声明时不指定具体数据类型，在使用时再指定具体数据类型。泛型可以提高代码的重用性、类型安全性和效率，避免重复编写相同逻辑但不同数据类型的代码。泛型还可以使用约束、反射和继承来实现更多的功能。

### C# 中泛型的特点是什么？
泛型的特性有以下几点：
 - 泛型可以提高代码的重用性，避免重复编写相同功能的类和方法，只需更改类型参数即可适应不同的类型。
 - 泛型可以提高代码的类型安全性，避免在运行时发生无效类型转换或装箱拆箱操作，减少错误和性能损失。
 - 泛型可以提高代码的效率，因为它可以避免使用 object 类型作为通用类型，从而减少堆分配和垃圾回收的开销。
 - 泛型可以使用约束来限制类型参数的范围，从而访问特定类型的成员或实现特定接口。
 - 泛型可以使用反射来获取类型参数的信息，在运行时动态创建或操作泛型类型和方法。

### C# 非泛型集合有什么？
非泛型集合类型是指在`System.Collections`命名空间中定义的一组集合类 ，它们可以存储任何类型的对象（称为元素）。非泛型集合类型与泛型集合类型有以下几点区别：
 - 非泛型集合类型不需要指定元素的数据类型，在添加或检索元素时需要进行装箱和拆箱操作，这会降低性能和安全性。泛型集合类型需要指定元素的数据类型，在添加或检索元素时不需要进行装箱和拆箱操作，这会提高性能和安全性。
 - 非泛型集合类型不支持协变和逆变特性，即不能将一个集合赋值给另一个具有不同元素数据类型的集合。泛型集合类型支持协变和逆变特性，即可以将一个集合赋值给另一个具有兼容元素数据类型的集合。

常用的非泛型集合类型包括：
 - ArrayList：表示一个可动态调整大小的数组列表
 - Hashtable：表示一个基于键值对的哈希表
 - Queue：表示一个先进先出（FIFO）的队列
 - Stack：表示一个后进先出（LIFO）的栈
 - SortedList：表示一个根据键排序的键值对列表

### C# 中的反射是什么？
c#中反射是指在运行时动态地获取类型的信息并操作对象的能力。反射可以让你访问、检测和修改程序本身的状态或行为。反射还可以用于查看特性（attribute）信息，动态加载和使用类型，发出动态方法和程序集等。反射提高了程序的灵活性和扩展性，但也有一些缺点，比如性能问题和维护问题。

### 在C# 中如何使用反射？它有哪些应用场景？

反射是一种特殊技术，用于在运行时获取类型的元数据信息，并且动态创建或操作类型的实例。反射有以下应用场景：
 - 反射可以用于加载和使用外部程序集或类型，并且可以使用Assembly类来实现
 - 反射可以用于获取和修改类型的成员值或调用类型的成员方法，并且可以使用Type类和MemberInfo类来实现
 - 反射可以用于创建自定义特性并在运行时检索特性信息，并且可以使用Attribute类和CustomAttributeData类来实现

### 在C# 中如何使用特性？它有哪些作用？

特性是一种特殊类型，用于为程序元素（如类型、成员、参数等）提供额外的元数据信息。特性有以下作用：
 - 特性可以用于控制编译器的行为或指示编译器执行特定的操作，并且可以使用预定义的特性或自定义特性来实现
 - 特性可以用于描述程序元素的特征或功能，并且可以使用反射技术在运行时检索特性信息
 - 特性可以用于扩展程序元素的功能或增强程序元素的可读性，并且可以使用方括号（[]）来应用特性

## I/O

### C# 中的 I/O 类是什么？
C# 中的 I/O 类是指 `System.IO` 命名空间中的一些类，它们用于对文件、目录、流、压缩等进行输入和输出操作。一些常用的 I/O 类有：
 - **File**：提供用于创建、复制、删除、移动和打开文件的静态方法，并可帮助创建 FileStream 对象。
 - **FileInfo**：提供用于创建、复制、删除、移动和打开文件的实例方法，并可帮助创建 FileStream 对象。
 - **Directory**：提供用于创建、移动和枚举目录和子目录的静态方法。
 - **DirectoryInfo**：提供用于创建、移动和枚举目录和子目录的实例方法。
 - **Path**：提供用于以跨平台的方式处理目录字符串的方法和属性。
 - **Stream**：提供对字节序列进行读取和写入操作的抽象基类。
 - **FileStream**：用于对文件进行读取和写入操作。
 - **MemoryStream**：用于作为后备存储对内存进行读取和写入操作。
 - **BinaryReader 和 BinaryWriter**：用于将基元数据类型作为二进制值进行读取和写入。
 - **StreamReader 和 StreamWriter**：用于通过使用编码值在字符和字节之间来回转换来读取和写入字符。
 - **DeflateStream 和 GZipStream**：用于使用不同的算法对流进行压缩和解压缩。

### 如何在C#中进行文件处理
`System.IO` 命名空间提供了四个类，允许操作单个文件并与服务器目录结构交互。`Directory` 和`File`派生自`System.Object`，支持使用各种静态方法创建、复制、移动和删除文件。但是，它们只包含静态方法，不能实例化。 `FileInfo` 和 `DirecotryInfo` 类型派生自抽象类 `FileSystemInfo`。通常用于获取文件或目录的完整详细信息，因为`FileInfo` 和 `DirecotryInfo`的成员倾向于返回强类型对象。`FileInfo` 和 `DirecotryInfo`实现的方法与`Directory` 和`File`的公共方法大致相同，但它们是有状态的，并且这些类的成员不是静态的。

## 序列化
### C# 中的序列化是什么？
C#中的序列化是指将对象的状态（即字段和属性）转换为二进制或文本格式的过程。这样做的目的是为了保存对象的状态，或者将对象传输到另一个应用程序或网络上。C#提供了`System.Runtime.Serialization`命名空间来支持序列化和反序列化（即将序列化数据转换回对象）操作。支持的类型有：
 - 二进制序列化：将对象转换为二进制格式，并且可以保留对象的公共和私有字段。这种序列化方式适合在同一应用程序域内或跨应用程序域传输对象。
 - XML序列化：将对象转换为XML格式，并且只能保留对象的公共字段和属性。这种序列化方式适合在不同平台之间传输对象或保存对象为可读格式。
 - SOAP序列化：将对象转换为SOAP格式，并且只能保留对象的公共字段和属性。这种序列化方式适合在基于SOAP协议的Web服务之间传输对象。
 - JSON序列化：将对象转换为JSON格式，并且只能保留对象的公共字段和属性。这种序列化方式适合在基于JSON协议的Web服务之间传输对象或保存对象为可读格式。


## 垃圾回收
### C#中的Dispose和Finalize有什么区别？
C# 中的Dispose和Finalize方法都是用来释放对象占用的非托管资源（如文件操作、窗口句柄、网络连接、数据库连接等）的方法。它们有以下几点区别：

 - Dispose方法是在IDisposable接口中定义的，而Finalize方法是在Object类中定义的。实现IDisposable接口的类必须提供一个Dispose方法，让用户代码可以显式地调用它来释放资源。Finalize方法是一个保护方法，只有当垃圾回收器（GC）回收对象时才会被调用，以防用户代码忘记调用Dispose方法。
 - Dispose方法可以在任何时候被用户代码调用，而Finalize方法不能被用户代码直接调用，只能由GC在对象不可达时调用。Dispose方法可以控制资源释放的时机，而Finalize方法不能保证资源释放的时机，因为GC的运行是不确定的。
 - Dispose方法可以多次被调用，而Finalize方法只能被调用一次。如果一个对象已经被Dispose了，再次调用Dispose不会有任何影响。但如果一个对象已经被Finalize了，就不能再被Finalize了，因为它已经从终结器队列中移除了。
 - Dispose方法可以释放托管和非托管资源，而Finalize方法只能释放非托管资源。Dispose方法可以通过调用其他对象的Dispose方法来释放它们占用的托管资源，而Finalize方法不能这样做，因为其他对象可能已经被GC回收了。

### 什么是循环引用？
循环引用是指两个或多个对象之间相互引用的情况，导致它们无法被垃圾回收器回收。循环引用可能会造成内存泄漏和性能下降。循环引用可以通过使用弱引用、解除引用或使用依赖注入等方式来避免或解决。

### C# 中析构函数是什么？
析构函数是一种特殊的方法，用于销毁类的对象。析构函数与类同名，并且前面有一个波浪号（`~`）。析构函数没有参数列表和返回类型，并且每个类只能有一个析构函数。

### C# 中的对象池是什么？
C# 中对象池是一种设计模式，它用于管理对象集合，并提供对这些对象进行复用而不需要创建新对象或销毁旧对象的机制。对象池可以提高性能和内存效率，特别是对于创建成本高昂或数量有限的对象。对象池通常需要实现创建、获取、释放和清理等操作。

## 异常

### C# 中异常是什么？如何处理异常？
异常是一种特殊类型，用于表示程序运行时发生了错误或异常情况。异常通常由`try-catch-finally`语句块来处理，`try`块包含可能抛出异常的代码段，`catch`块包含捕获并处理异常的代码段，`finally`块包含无论是否发生异常都要执行的代码段。

### C#中可以执行多个catch块吗？
可以在一个 `try` 语句中使用多个 `catch` 块。这是因为每个 `catch` 块都可以捕获不同的异常。

### C# 中“throw”和“throw ex”有什么区别？
先看看下面的语句示例：
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace TestingThrowExceptions {
    class Program {
        public void ExceptionMethod() {
            // 这是throw
            throw new Exception("Original Exception occurred in ExceptionMethod");
        }
        static void Main(string[] args) {
            Program p = new Program();
            try {
                p.ExceptionMethod();
            } catch (Exception ex) {
                // 这是throw ex
                throw ex;
            }
        }
    }
}
```

throw 和 throw ex 都可以用来重新抛出异常，但区别在于 throw 会保留原始异常的堆栈跟踪信息，而 throw ex 会重置堆栈跟踪信息，从而丢失原始异常发生的位置。

### C# 中什么是自定义异常？

C# 中自定义异常是指用户自己定义的派生自 `Exception` 类或其子类的异常类型。自定义异常可以用于处理特定于应用程序或业务逻辑的错误情况，并提供更多的信息或功能。自定义异常需要使用 public 访问修饰符，并提供合适的构造函数和属性。

### 列出C# 中最常用的异常类型

C# 中最常用的异常类型有：
 - **System.Exception**：所有异常类型的基类
 - **System.SystemException**：由 CLR 抛出或由系统 API 调用失败时抛出的异常类型
 - **System.ApplicationException**：由应用程序代码抛出或派生自定义异常时使用的异常类型
 - **System.NullReferenceException**：当试图访问 null 对象引用时抛出的异常类型
 - **System.IndexOutOfRangeException**：当试图访问超出数组界限或集合范围时抛出的异常类型
 - **System.ArgumentException**：当向方法提供无效参数时抛出的异常类型
 - **System.InvalidOperationException**：当调用某个操作时对象状态不正确时抛出的异常类型
 - **System.IO.IOException**：当发生输入/输出错误时抛出的异常类型
 - **System.FormatException**：当格式化字符串或转换数据时格式无效时抛出的异常类型
 - **System.DivideByZeroException**：当试图除以零时抛出的异常类型

## 多线程

### C# 中多线程是什么？它有哪些优缺点？
.NET 的多线程是指在 .NET 程序中可以同时运行多个不同的线程来执行不同的任务。.NET 提供了一些类和方法来创建和控制线程，如 `System.Threading.Thread` 类， `System.Threading.ThreadPool` 类， `System.Threading.Tasks.Task` 类等。使用多线程可以提高应用程序的响应能力，并利用多处理器或多核系统提高应用程序吞吐量。但是使用多线程也需要注意一些问题，如竞争条件，同步，异常处理等。

### C# 中的线程生命周期是什么？
线程生命周期是指线程从创建到终止的过程。C#中的线程在任何时刻都处于以下几种状态之一：

 - **未启动状态**：当创建一个Thread类的实例时，它处于未启动状态，意味着线程还没有开始运行。或者换句话说，Start()方法还没有被调用。
 - **可运行状态**：当调用Start()方法时，线程从未启动状态转移到可运行状态。这意味着线程有资格运行，但它还没有运行，因为线程调度器还没有选择它运行。如果有多个线程处于可运行状态，那么线程调度器将决定哪个线程从可运行状态转移到下一个状态，即运行状态。
 - **运行状态**：当线程调度器选择一个线程运行时，它进入运行状态。在执行过程中，线程处于运行状态。从运行状态，一个线程可以进入不可运行状态、可运行状态或死亡状态。
 - **不可运行状态**：当线程遇到以下情况之一时，它进入不可运行状态，此时线程不再有资格运行，但即使在这种状态下，线程仍然被认为是活着的。
   - 当调用Sleep()方法时，暂时挂起当前执行的线程。
   - 当调用Wait()方法时，使当前执行的线程等待另一个线程完成。
   - 当发生I/O请求时，阻塞当前执行的线程。
   - 当调用Suspend()方法时，暂停当前执行的线程。
 - **死亡状态**：当线程完成其任务时，它进入死亡、终止或中止状态。

### C# 中线程池是什么？
C# 中的线程池是一种多线程处理形式，处理过程中将任务添加到队列然后通知提前创建好的工作线程，然后工作线程再从任务队列中获取任务并执行。

可以使用 `System.Threading.ThreadPool` 类来使用线程池，它提供了一些属性和方法来控制线程池的大小、任务的排队和执行。

也可以使用 `System.Threading.Tasks.Task` 和 `System.Threading.Tasks.Task<TResult>` 类来创建在线程池线程上执行异步任务的对象。

### C# 中如何使用异步编程？它有哪些好处？
异步编程是一种特殊技术，用于创建不阻塞主线程的任务或子程序。异步编程有以下好处：

 - 异步编程提高了程序的性能和响应性，并且避免了UI线程的卡顿或假死
 - 异步编程简化了并发和并行编程的逻辑，并且使用async和await关键字来实现
 - 异步编程支持多种返回类型，包括`void`、`Task`、`Task<T>`等，并且可以使用异常处理和取消令牌等机制

### 为什么在 C# 中使用 Async 和 Await？

C# 中使用 `Async` 和 `Await` 的原因是为了实现异步编程，即在不阻塞主线程的情况下执行耗时的操作，如网络请求、文件读写、数据库操作等。使用 `Async` 和 `Await` 可以让你的代码更简洁、清晰和高效，同时提高应用程序的性能和响应能力。

`Async` 和 `Await` 是两个关键字，它们配合使用可以让你在方法中等待异步任务的完成，而不会阻塞当前线程。`Async` 关键字用于修饰方法，表示该方法是异步的，可以使用 `Await` 关键字。

Await 关键字用于等待一个返回 `Task` 或 `Task<T>` 的异步方法的结果，当遇到 Await 时，当前方法会被挂起，直到异步任务完成，然后继续执行后续的代码。在等待的过程中，控制权会返回给调用者，以便执行其他的工作。

### C#中的竞争条件是什么？
竞争条件是指当两个或多个线程访问共享数据，并且尝试同时改变它时，就发生争用的情况。这可能会导致数据损坏或不确定性的行为。竞争条件可以分为互斥和同步两种。

互斥是指两个或多个线程要抢占使用某个临界资源（不能被多个线程同时使用的资源，如打印机，变量）而产生制约关系。

同步是指两个或多个线程彼此之间存在内在的制约关系（前一个进程执行完，其他的进程才能执行），如严格轮转法。

要避免竞争条件，可以使用一些线程同步的方法，如锁、信号量、原子操作等。
