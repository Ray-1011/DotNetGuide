---
outline: deep
---

# MySQL面试题（基础篇一）

## 基础

### SQL的生命周期是什么？

SQL的生命周期是 SQL 语句从客户端发送到服务器端，再从服务器端返回结果给客户端的整个过程。如下：

- 编写：客户端编写 SQL 语句，并通过网络发送给服务器端
- 解析：服务器端接收到 SQL 语句后，先进行词法和语法分析，检查语句是否符合规范，并生成一个解析树
- 优化：服务器端对解析树进行优化，选择最佳的执行计划，比如选择合适的索引、确定连接顺序、决定是否使用临时表等
- 执行：服务器端根据优化后的执行计划，调用存储引擎的接口，对数据进行操作，并返回结果给客户端
- 返回：客户端接收到服务器端返回的结果，并进行处理或展示

### 优化器的执行过程？

优化器是 MySQL 中负责生成最佳执行计划的组件。大致的阶段为：

- 查询重写：对解析树进行一些改写和转换，以消除冗余、简化逻辑、提高效率等。比如将子查询转换为连接、将or条件转换为union等。
- 统计信息收集：优收集各种统计信息，以便估算不同执行计划的代价。比如表和索引的大小、基数、选择度、分布等。
- 执行计划生成：根据统计信息和代价模型，生成多个候选的执行计划，并比较它们的代价，选择最低代价的执行计划作为最终结果。比如选择扫描方式、确定连接顺序、选择连接算法等。
- 执行计划缓存：将生成的执行计划缓存起来，以便下次遇到相同或类似的 SQL 语句时，可以直接使用缓存的执行计划，而不需要重新优化。


### 什么是数据库连接池?为什么需要数据库连接池呢?

数据库连接池是一种管理数据库连接的技术，它维护了一定数量的已经建立好的数据库连接，并根据应用程序的请求分配和回收这些连接。数据库连接池的目的是为了提高数据库访问的效率和性能。因为建立和关闭数据库连接是一个耗时和消耗资源的操作，如果每次访问数据库都要重新建立连接，则会增加系统的开销和响应时间。而通过数据库连接池，可以复用已经存在的连接，减少连接创建和关闭的次数，提高响应速度。同时，数据库连接池还可以有效地控制并发访问数据库的数量，避免因为连接过多而导致数据库服务器负载过高或崩溃。

### MySQL有关权限的表都有哪几个？

MySQL有关权限的表主要有以下几个：

- **user表**：存储用户的全局权限和认证信息，比如用户名、密码、主机名、最大连接数等。
- **db表**：存储用户对数据库级别的权限，比如是否可以创建、删除、修改数据库等。
- **tables_priv表**：存储用户对表级别的权限，比如是否可以查询、插入、更新、删除表中的数据等。
- **columns_priv表**：存储用户对列级别的权限，比如是否可以查询、插入、更新、删除表中某些列的数据等。
- **procs_priv表**：存储用户对存储过程和函数级别的权限，比如是否可以创建、执行、修改、删除存储过程和函数等。

这些表都位于MySQL数据库中，可以通过`SELECT`命令来查看它们的内容。当执行`GRANT`或者`REVOKE`命令时，这些表会被相应地更新。当执行`FLUSH PRIVILEGES`命令时，这些表会被重新加载到内存中

### MySQL的六种关联查询有什么

关联查询是指在一个查询中涉及到多个表的数据，通过连接条件来获取数据。MySQL中有六种关联查询：

- **笛卡尔积**：将两个或多个表的所有行进行组合，连接后的行数为两个或多个表的乘积数。这种查询一般没有实际意义，因为没有指定连接条件，会产生大量无用的数据
- **内连接**：有两种格式，显式的和隐式的，返回连接表中符合连接条件和查询条件的数据行。这种查询一般用于获取两个或多个表中有关联的数据
- **外连接**：分为左外连接、右外连接和全外连接，返回连接表中符合连接条件和查询条件的数据行，以及左表或右表或两个表中没有匹配的数据行。这种查询一般用于获取某个表中有而另一个表中没有的数据
- **自连接**：是指当前表与自身的连接查询，关键点在于虚拟化出一张表给一个别名。这种查询一般用于获取表中某个字段的值是引用另一个字段的值的情况，比如员工与上司之间的关系

### MySQL自增主键用完了怎么办？

如果字段是UNSIGNED INT类型，最大值则是4294967295。如果自增主键达到了最大值，则再插入新记录时会报错。可选的方法：

- 修改字段的数据类型，使用更大范围的整数类型，如BIGINT。这种方法可以延缓自增主键用完的问题，但是会增加存储空间和计算开销。
- 修改字段的符号位，使用UNSIGNED属性。这种方法可以将自增主键的范围扩大一倍，但是不能存储负数。
- 修改表的AUTO_INCREMENT属性，重新设置起始值。这种方法可以重复利用已经删除的主键值，但是可能会导致主键冲突或数据不一致。
- 放弃使用自增主键，使用其他方式生成主键值。这种方法可以避免自增主键用完的问题，但是需要考虑主键值的唯一性、有序性、可用性等因素。

### 数据库是否支持emoji表情存储？

emoji表情是一种特殊的字符，它们属于Unicode字符集中的扩展区域，需要使用4个字节来存储。因此，如果要在MySQL数据库中存储emoji表情，需要满足以下条件：

- 数据库的字符集要支持4个字节的字符，比如utf8mb4或者utf16等
- 数据库的连接编码也要支持4个字节的字符，比如utf8mb4或者utf16等
- 数据库中存储emoji表情的字段类型要支持4个字节的字符，比如varchar或者text等

如果数据库不支持emoji表情存储，可以通过以下步骤来操作：

- 修改数据库的字符集为utf8mb4或者utf16，并且修改相应的排序规则。
- 修改数据库连接编码为utf8mb4或者utf16，并且确保客户端和服务器之间使用相同的编码。
- 修改数据库中存储emoji表情的字段类型为varchar或者text，并且指定字符集为utf8mb4或者utf16。

### MySQL中DATETIME和TIMESTAMP的区别

DATETIME和TIMESTAMP都是用来存储日期和时间的数据类型，区别为：

- 范围不同：**DATETIME**的范围是'1000-01-01 00:00:00'到'9999-12-31 23:59:59'，**TIMESTAMP**的范围是'1970-01-01 00:00:01' UTC到'2038-01-19 03:14:07' UTC。
- 精度不同：**DATETIME**可以存储6位小数的秒，即微秒级别的精度，**TIMESTAMP**也可以存储6位小数的秒，但只有在定义列时指定了精度才会生效，否则默认为0位小数，即秒级别的精度。
- 时区不同：**DATETIME**是以本地时区存储和显示日期和时间，不受时区变化的影响，**TIMESTAMP**是以UTC（协调世界时）存储日期和时间，但在显示时会根据当前时区进行转换，因此受时区变化的影响。

### 如何在Unix和MySQL时间戳之间进行转换？

Unix时间戳是指从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，不考虑闰秒。MySQL时间戳是指从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，考虑闰秒。

Unix时间戳转换为MySQL日期时间格式的方法

- 使用`FROM_UNIXTIME`函数将，比如`SELECT FROM_UNIXTIME(1639560000);`
- 使用`CONVERT_TZ`函数，并且指定时区，比如`SELECT CONVERT_TZ(FROM_UNIXTIME(1639560000), '+00:00', '+08:00');`

MySQL日期时间格式转换为Unix时间戳

- 使用`UNIX_TIMESTAMP`函数，比如`SELECT UNIX_TIMESTAMP('2021-12-15 16:00:00');`
- 使用`TIMESTAMPDIFF`函数，并且指定时区，比如`SELECT TIMESTAMPDIFF(SECOND, '1970-01-01 00:00:00', CONVERT_TZ('2021-12-15 16:00:00', '+08:00', '+00:00'));`

### 200台db，在最快时间之内重启。

- 使用批量ssh工具pssh来对需要重启的机器执行重启命令。这种方法简单易用，但是可能存在网络延迟或者失败重试的问题。
- 使用MySQL集群管理工具，比如MySQL Cluster Manager或者MySQL Shell等，来对集群中的节点进行重启。这种方法可以利用集群工具的特性，比如自动检测节点状态，自动恢复故障节点，自动平衡负载等，来保证重启过程的稳定性和可靠性。

## SQL优化篇

### MySQL如何优化DISTINCT？

DISTINCT是用来去除查询结果中重复记录的关键字。MySQL如何优化DISTINCT取决于查询语句中是否有GROUP BY或ORDER BY子句。

- 如果没有GROUP BY或ORDER BY子句，MySQL会使用临时表来存放查询结果，并去除重复记录。如果查询结果很大，临时表可能会使用磁盘空间，影响性能。为了避免这种情况，可以尽量减少查询结果集中需要去重复的字段数量，或者使用索引来加速查询。
- 如果有GROUP BY子句，MySQL会根据GROUP BY子句中指定的字段进行分组，并去除重复记录。如果查询结果很大，MySQL可能会使用临时表和文件排序来处理分组。为了避免这种情况，可以尽量减少GROUP BY子句中指定的字段数量，或者使用索引来加速分组。
- 如果有ORDER BY子句，MySQL会根据ORDER BY子句中指定的字段进行排序，并去除重复记录。如果查询结果很大，MySQL可能会使用临时表和文件排序来处理排序。为了避免这种情况，可以尽量减少ORDER BY子句中指定的字段数量，或者使用索引来加速排序。

### MySQL中Where子句如何优化？

- 尽量使用等值查询或者前缀匹配查询，并且建立合适的索引
- 尽量避免使用函数操作或者计算、隐式类型转换、or 连接等影响索引使用的操作
- 尽量避免使用全表扫描或者全索引扫描的方式查询数据，而是使用覆盖索引或者回表查询的方式
- 尽量避免使用子查询或者关联查询，并且将复杂的查询拆分成多个简单的查询
- 避免在WHERE子句中对字段进行NULL值判断，因为这样会导致全表扫描，同时也会使索引失效。

### 超大分页或深分页如何处理？

超大分页或深度分页指的是查询结果集很大，并且需要跳过很多页才能到达目标页的情况。这种情况下，使用 `limit` 的方式会导致性能下降，因为需要扫描很多无用的记录。可以使用

- 索引覆盖扫描，即让查询只涉及索引列，不需要访问数据行，这样可以减少IO开销和内存占用。
- 子查询优化，即先根据条件查询出主键或唯一键，然后再根据主键或唯一键查询其他列，这样可以减少扫描范围和排序开销。
- 游标或者递增条件查询，即记录上次查询的最后一个主键或唯一键值，然后下次查询时使用该值作为过滤条件，这样可以避免重复扫描之前的记录。

例如：以`limit 1000000`作为例子
- 索引覆盖：`select id,name from employee where limit 1000000,10;`
- 子查询优化：`SELECT * FROM t WHERE id IN (SELECT id FROM t ORDER BY id LIMIT 1000000,10);`
- 游标或者递增条件查询：`select id,name from employee where id>1000000 limit 10;`

### 大表查询如何优化？

- 使用索引，根据查询条件和排序规则，合理地创建和使用索引，以减少全表扫描和临时表的开销，提高查询效率
- 进行分区或者分表，将数据按照一定的规则划分成多个小表，从而减少单个表的数据量和索引大小，提高查询效率
- 使用缓存，根据数据的访问频率和更新频率，将部分数据缓存在内存中，以减少对数据库的访问压力和响应时间，提高查询效率
- 进行归档或者清理，将过期或者无用的数据删除或者转移到历史表中，从而减少主表的数据量和索引大小，提高查询效率
- 进行汇总或者聚合，将需要频繁统计或者分析的数据预先计算并存储在汇总表或者聚合表中，从而避免对大表进行复杂的计算操作，提高查询效率

### 如何优化长难句

- 分析执行计划。使用 `EXPLAIN` 或 `SHOW PROFILE` 等命令来查看查询语句的执行计划和性能瓶颈，找出影响效率的地方，如全表扫描、临时表、排序等
- 优化子查询。尽量避免使用子查询，尤其是相关子查询，可以考虑使用连接、视图、派生表等替代
- 优化连接。尽量使用等值连接，避免使用外连接和交叉连接，选择合适的连接顺序和连接类型，如内连接、左连接、右连接等
- 优化排序。尽量避免使用 ORDER BY 子句，如果必须使用，可以考虑在排序字段上建立索引，或者使用文件排序算法
- 优化分组。尽量避免使用 GROUP BY 子句，如果必须使用，可以考虑在分组字段上建立索引，或者使用临时表进行分组
- 优化聚合函数。尽量避免使用聚合函数，如 COUNT、SUM、AVG 等，如果必须使用，可以考虑在聚合字段上建立索引，或者使用缓存存储聚合结果
- 优化限制。尽量避免使用 LIMIT 子句，如果必须使用，可以考虑在限制字段上建立索引

### MySQL一天五万条以上的增量，预计运维三年,可能面临以下几个问题：

- 使用分区表或者分表分库，将大表按照时间、地域、类型等条件划分为多个小表，并分布在不同的服务器上，减少数据量和并发压力
- 使用索引覆盖扫描、延迟关联、子查询优化等技巧，提高查询效率和性能
- 使用归档表或者历史表，将过期或者不常用的数据转移到另外的表中，并定期清理或备份，释放空间和资源
- 使用数据压缩或者列存储引擎，减少数据占用的空间和IO开销
- 使用数据冗余或者缓存技术，提高数据访问的速度和可用性

### 百万级别或以上的数据，你是如何删除的？

- 分批删除。将要删除的数据按照主键或者时间等条件分成多个小批次，每次只删除一定数量的数据，并提交事务，释放锁和资源。例如：`DELETE FROM t WHERE id BETWEEN 1 AND 1000;`
- 分区或者分表分库。将要删除的数据单独存储在一个分区或者一个表中，并定期清理或备份，然后直接删除整个分区或者表，避免逐行删除。例如：`ALTER TABLE t DROP PARTITION p1;`
- 截断表或者重建表。将要保留的数据先复制到一个临时表中，并重建索引和约束，然后直接截断原表或者用临时表替换原表，避免逐行删除。例如：`CREATE TABLE tmp AS SELECT * FROM t WHERE id > 1000000;TRUNCATE TABLE t;RENAME TABLE tmp TO t;`















