---
title: MySQL面试题-引擎与事务
editLink: true
head:
  - - meta
    - name: description
      content: MySQL面试题，MySQL引擎、事务、乐观锁、悲观锁
layout: doc
outline: deep
---

# MySQL面试题（引擎与事务篇）
## 引擎篇
### MySQL中有哪些引擎？
常见的引擎有：

- MyISAM：是MySQL默认的存储引擎之一，支持全文索引、压缩、空间函数等特性，适合于以读为主、数据量小、无事务要求的应用场景。
- InnoDB：是MySQL默认的存储引擎之一，支持事务、行级锁、外键约束、多版本并发控制等特性，适合于以写为主、数据量大、有事务要求的应用场景。
- Memory：是一种基于内存的存储引擎，支持哈希索引和B树索引，适合于临时数据或频繁访问的数据，但是不支持事务和外键等特性。
- Archive：是一种只支持插入和查询操作的存储引擎，适合于存储归档数据或日志数据，支持压缩和行级锁等特性。
- CSV：是一种将数据以逗号分隔符格式存储在文本文件中的存储引擎，适合于数据交换或备份等场景。
- Merge：是一种将多个MyISAM表合并为一个逻辑表的存储引擎，适合于分区查询或并行查询等场景。

### MyISAM与InnoDB的分别是什么？
- MyISAM是MySQL默认的存储引擎，它支持全文索引、压缩、空间函数等特性，但是不支持事务、外键、行级锁等特性。它适合于查询密集、并发低、不需要事务保证的应用场景。
- InnoDB是MySQL最流行的存储引擎之一，它支持事务、外键、行级锁、崩溃恢复等特性，但是不支持全文索引、压缩等特性。它适合于更新密集、并发高、需要事务保证的应用场景。

如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。

### InnoDB 的四大特性？

- **支持事务**：InnoDB 支持ACID（原子性、一致性、隔离性、持久性）事务模型，提供了提交、回滚、崩溃恢复等功能，保证了数据的完整性和一致性。
- **行级锁**：InnoDB 实现了行级锁定机制，即对数据进行修改时只锁定所涉及的行，而不影响其他行的访问。行级锁可以提高并发性能，减少锁冲突和死锁。
- **外键约束**：InnoDB 支持外键约束，即可以在表之间建立参照完整性约束，保证了数据之间的关联性和一致性。
- **多版本并发控制**：InnoDB 通过多版本并发控制（MVCC）机制实现了非锁定读取，即读取操作不会加锁，而是通过保存数据在某个

### MyISAM和InnoDB的区别？

- 事务支持：MyISAM 不支持事务，InnoDB 支持事务，可以保证数据的ACID特性。
- 锁机制：MyISAM只支持表级锁，InnoDB支持行级锁和表级锁，可以提高并发性能。
- 索引结构：MyISAM使用B+树作为索引结构，索引文件和数据文件是分开的，InnoDB也使用B+树作为索引结构，但是主键索引和数据是存储在一起的，称为聚集索引。
- 外键支持：MyISAM不支持外键，InnoDB支持外键，可以保证数据的完整性和一致性。
- 全文索引支持：MyISAM支持全文索引，可以进行全文检索，InnoDB在MySQL5.6版本之后也支持全文索引。
- 崩溃恢复：MyISAM在数据库崩溃后无法保证数据的安全性，可能会丢失或损坏数据，InnoDB在数据库崩溃后可以利用重做日志和回滚日志来恢复数据，保证数据的安全性。

### MySQL数据库表类型有哪些？
MyISAM、InnoDB、HEAP、BOB,ARCHIVE,CSV等。

MyISAM：成熟、稳定、易于管理，快速读取。一些功能不支持（事务等），表级锁。

InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引等。

### 什么是 InnoDB 的页、区、段？

InnoDB 的页、区、段是指 InnoDB 存储引擎在逻辑上组织和管理数据的三个层次：

- 页（page）是 InnoDB 磁盘管理的最小单位，默认的页大小为 16KB，可以通过 `innodb_page_size` 参数进行修改。页有不同的类型，如数据页、索引页、undo 页、系统页等，用来存储不同的数据和信息。
- 区（extent）是由连续的页组成的空间，无论页的大小怎么变，区的大小总是为 1MB。为了保证区中的页的连续性，InnoDB 存储引擎一次从磁盘申请 4~5 个区。在每个段开始时，先用 32 个页大小的碎片页来存放数据，在使用完这些页之后才开始申请 64 个连续的页。
- 段（segment）是由一个或多个区组成的空间，区在段中不要求相邻。常见的段有数据段、索引段、回滚段等。数据段就是 B+ 树的叶子节点，索引段就是 B+ 树的非叶子节点，回滚段用来存储 undo 信息。对于段的管理都是由存储引擎自身完成的，用户不能也没有必要对其进行管理。

### 页由哪些数据组成？

由以下几部分数据组成：

- 文件头部（File Header）：占 38 个字节，包含了该页的类型、创建时间、上一个和下一个相邻页的编号等信息。
- 页头部（Page Header）：占 56 个字节，包含了该页中记录的数量、空闲空间偏移量、最小记录偏移量等信息。
- 垃圾链表（Garbage List）：占用不定长度，记录了该页中已经删除或更新过的记录所占用的空间位置和大小。
- 用户记录（User Records）：占用不定长度，存储了该页中实际的数据记录，按照主键顺序排列。
- 页目录（Page Directory）：占用不定长度，存储了该页中用户记录的偏移量和顺序信息，方便快速定位记录。
- 文件尾部（File Trailer）：占 8 个字节，存储了该页的校验和信息。

### 页中插入记录的过程？

步骤如下：

- 首先判断该记录是否能够插入到该页中，如果不能，则需要进行分裂或合并操作。
- 然后在该页中找到合适的位置插入该记录，并更新相关信息，如记录数量、空闲空间偏移量等。
- 接着在该页的垃圾链表中查找是否有足够大的空间可以复用，如果有，则将该空间分配给新插入的记录，并从垃圾链表中删除该空间信息。
- 如果没有足够大的空间可以复用，则将新插入的记录放在该页剩余空间的最前面，并更新空闲空间偏移量。
- 最后在该页的目录中添加新插入记录的偏移量，并按照主键顺序排序。

### 什么是 Buffer Pool？

Buffer Pool 是 InnoDB 存储引擎的一个重要组成部分，它是一个内存中的缓冲区，用来缓存数据页和索引页，以提高数据访问的效率和性能。Buffer Pool 的大小可以通过 `innodb_buffer_pool_size`参数进行设置，一般建议设置为物理内存的 50%~80%

### 什么是 Change Buffer？

Change Buffer 是 InnoDB 存储引擎的另一个重要组成部分，它是 Buffer Pool 的一部分，用来缓存对非聚集索引的修改操作，以减少磁盘的读写次数。

当对非聚集索引进行插入、删除或更新操作时，InnoDB 存储引擎会将这些操作记录在 Change Buffer 中，而不是直接修改磁盘上的索引页。

在后台或下次查询时，InnoDB 存储引擎会将 Change Buffer 中的操作合并到磁盘上的索引页中。Change Buffer 的大小可以通过 `innodb_change_buffer_max_size` 参数进行设置，一般建议设置为 25%。

### myisamchk是用来做什么的？

myisamchk是一个用来检查和修复MyISAM表的工具，可以用来做：

- 检查MyISAM表是否有错误或损坏
- 修复MyISAM表中的错误或损坏
- 优化MyISAM表的存储空间和性能
- 分析MyISAM表的分布和特征

### MyISAM Static和MyISAM Dynamic有什么区别？

MyISAM Static和MyISAM Dynamic是MyISAM存储引擎的两种不同的格式，区别在于：

- MyISAM Static是指表中的所有字段都是固定长度的，例如char、int、date等。这种格式的优点是存储空间和性能较高，缺点是浪费空间和不支持BLOB或TEXT类型的字段。
- MyISAM Dynamic是指表中的某些字段是可变长度的，例如varchar、blob、text等。这种格式的优点是节省空间和支持BLOB或TEXT类型的字段，缺点是存储空间和性能较低。

### MyISAM引擎存储在哪里？

- .frm文件：存储表格的结构信息，如字段名、类型、索引等
- .MYD文件：存储表格的数据信息，按行顺序存放
- .MYI文件：存储表格的索引信息，使用B+树结构

### 主键使用自增ID还是UUID，为什么？

要根据具体的业务场景和需求来选择

- 自增ID是一个整数类型的值，它按照一定的步长递增，优点是简单易用，占用空间小，查询效率高；缺点是可能存在重复或穿透的风险，不利于分布式系统或水平拆分。
- UUID是一个由32个十六进制数字组成的字符串类型的值，它由一定的算法生成，优点是唯一性强，不依赖于数据库，适合分布式系统或水平拆分；缺点是占用空间大，查询效率低，不易排序和阅读。

### 自增表主键为什么不是最大id
比如，一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？

- 表类型如果是 MyISAM ，那 id 就是 8。
- 表类型如果是 InnoDB，那 id 就是 6。

InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失

### 数据表损坏的修复方式有哪些？

数据表损坏的修复方式主要取决于数据表使用的存储引擎。对于 MyISAM 存储引擎，可以使用：

- REPAIR TABLE 语句：这是最简单的修复方式，可以直接在 SQL 命令行中执行。例如：`REPAIR TABLE t`；
- myisamchk 工具：这是一个命令行工具，可以对 MyISAM 表进行检查和修复。例如：`myisamchk -r t.MYI`
- myisampack 工具：这是一个命令行工具，可以对 MyISAM 表进行压缩和优化，同时也可以修复一些损坏。例如：`myisampack t.MYI`

对于 InnoDB 存储引擎，可以使用：

- 使用 innodb_force_recovery 参数：这是一个配置文件参数，可以设置不同的值来启动 MySQL 服务器，并尝试恢复 InnoDB 表。例如：`innodb_force_recovery = 1`；
- 使用 innodb_recovery_update_relay_log 参数：这是一个配置文件参数，可以设置为 ON 来启动 MySQL 服务器，并尝试恢复 InnoDB 表，并更新中继日志。例如：`innodb_recovery_update_relay_log = ON`
- 使用 Percona Data Recovery Tool for InnoDB 工具：这是一个第三方工具，可以从损坏的 InnoDB 表中恢复数据，并生成 SQL 脚本。例如：`innodb_data_recovery_tool --export t.ibd`

## 事务篇

### 事务是什么？
事务是指一组对数据库数据进行访问和修改的操作序列，它具有原子性、一致性、隔离性和持久性四个特性，简称ACID。事务可以保证数据的完整性和一致性，防止并发操作引起的数据冲突或丢失。

### 事务的四大特性 (ACID)

- 原子性（Atomicity）：事务中的所有操作要么全部成功，要么全部失败，不会出现部分执行的情况。如果事务执行过程中发生错误，会回滚到事务开始前的状态，就像这个事务从未执行过一样。
- 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏，数据的状态保持一致。例如，在转账事务中，转出账户和转入账户的总金额不变。
- 隔离性（Isolation）：事务之间是相互隔离的，一个事务的执行不会受到其他事务的干扰。不同的事务看到的数据是不同的，根据隔离级别的不同，可以避免脏读、不可重复读和幻读等问题。
- 持久性（Durability）：事务一旦提交，对数据的修改就是永久的，即使系统发生故障也不会丢失。

### 什么脏读、不可重复读、幻读？

- 脏读（Dirty Read）：指一个事务读取到了另一个事务未提交的数据。这些数据可能会被回滚，导致读取到了不存在或错误的数据。
- 不可重复读（Non-repeatable Read）：指一个事务在多次读取同一数据时，由于其他事务对该数据进行了修改并提交，导致每次读取的结果不一致。
- 幻读（Phantom Read）：指一个事务在多次查询同一范围的数据时，由于其他事务对该范围的数据进行了插入或删除并提交，导致每次查询的结果集不一致。

### 事务的隔离级别？

事务的隔离级别是指数据库系统在并发执行多个事务时，如何控制事务之间的可见性和影响范围。SQL标准定义了四种隔离级别，分别是：

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :------: | :--: | :--------: | :--: |
|  读未提交  |  是  |     是     |  是  |
|  读已提交  |  否  |     是     |  是  |
| 可重复读  |  否  |     否     |  是  |
|  串行化   |  否  |     否     |  否  |

从上表可以看出，隔离级别越高，能够解决的并发问题越多，但是也会带来更多的开销和限制。MySQL默认使用可重复读作为隔离级别，在InnoDB存储引擎中，通过多版本并发控制（MVCC）机制实现了高效的可重复读。

### MySQL的默认事务隔离级别是？
MySQL的默认事务隔离级别是可重复读（REPEATABLE READ），这说明在同一个事务中多次读取同样的数据结果是一致的，不会受到其他事务的影响。这个级别可以避免脏读和不可重复读，但是不能避免幻读

### 什么是 MVCC 以及实现？
MVCC的全称是多版本并发控制 (Multi-Version Concurrency Control)，它是一种优化并发性能的技术，它可以让一个事务读取到其他事务提交前的数据快照，从而避免加锁和等待。

MVCC只在读已提交 (Read Committed) 和可重复读 (Repeatable Read) 两个隔离级别下工作，其他两个隔离级别不使用MVCC机制

### ACID 特性是如何实现的？
ACID是事务的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。InnoDB通过以下方式实现了这四个特性：

- 原子性：InnoDB 通过 **undo log** 来实现原子性，即在执行事务时，会记录所有修改前的数据状态，如果事务失败或者回滚，就可以利用 **undo log** 恢复到原来的状态。
- 一致性：InnoDB 通过一系列的完整性约束来实现一致性，例如主键约束、外键约束、唯一约束等，这些约束可以保证数据不会出现逻辑错误或者冲突。以及通过**redo log**来记录事务对数据的修改，如果事务执行过程中发生系统崩溃或者断电等故障，就可以根据**redo log**来恢复数据到最新状态。
- 隔离性：InnoDB 通过锁和 MVCC（多版本并发控制）来实现隔离性，即在不同的隔离级别下，为事务提供不同程度的并发访问保护，防止脏读、不可重复读、幻读等问题的发生。它的实现原理是通过锁机制来保证，例如共享锁、排他锁、间隙锁等，以及通过多版本并发控制（MVCC）来提高并发性能，通过给每个事务分配一个唯一的事务ID和每行数据分配一个行版本号来实现。
- 持久性：InnoDB 通过 redo log 来实现持久性，即在执行事务时，会将所有的修改记录到日志文件中，并保证日志文件在事务提交前被刷新到磁盘上，这样即使发生崩溃，也可以利用日志文件恢复数据。

### MySQL的GTID是什么？

GTID（Global Transaction ID）是全局事务标识符， 是一个已提交事务的编号，且是全局唯一的。

GTID的作用是：
 - 简化主从复制的配置和故障转移，不需要指定二进制日志文件名和位置。
 - 保证主从数据的一致性，避免复制延迟或丢失。
 - 支持多源复制和并行复制，提高复制效率和可扩展性。

### SQL 约束有哪几种呢？
SQL 约束是指在创建或修改表时对表的列或关系施加的一些限制条件，用于保证数据的完整性和一致性。SQL 约束有：
- 主键约束（PRIMARY KEY），用于标识表中每一行的唯一性，一个表只能有一个主键。
- 外键约束（FOREIGN KEY），用于建立两个表之间的引用关系，保证参照完整性。
- 唯一约束（UNIQUE），用于保证表中某一列或某几列的值不重复。
- 非空约束（NOT NULL），用于保证表中某一列的值不能为空。
- 检查约束（CHECK），用于保证表中某一列的值满足指定的条件。

### 完整性约束包括哪些？

完整性约束是指数据库中对数据正确性和一致性的限制条件，它可以保证数据的质量和有效性。完整性约束包括：

- 实体完整性：保证每个实体（表）都有一个唯一标识（主键），并且主键不能为NULL或者重复
- 参照完整性：保证两个实体（表）之间的关联（外键）是有效的，即外键值必须在参照表中存在或者为NULL
- 域完整性：保证每个属性（列）的取值符合其定义域（数据类型、范围、格式等）的要求
- 用户自定义完整性：保证用户根据业务逻辑或者规则定义的其他完整性约束，如唯一性约束、检查约束、触发器等

### Innodb的事务实现原理？

Innodb的事务实现原理主要依赖于两种日志：重做日志（Redo Log）和回滚日志（Undo Log）。重做日志用来保证事务的持久性，它记录了数据页的物理修改，以保证在系统崩溃后可以恢复数据。回滚日志用来保证事务的原子性和一致性，它记录了数据页的逻辑修改，以保证在事务回滚时可以撤销修改 。Innodb的事务实现原理可以简单描述如下：

- 当事务开始时，Innodb会为该事务分配一个唯一的事务ID，并记录在事务系统表中
- 当事务对数据进行修改时，Innodb会先将修改后的数据写入到内存缓冲池中，并将修改操作记录到重做日志缓冲区中
- 当事务提交时，Innodb会将重做日志缓冲区中的内容刷新到重做日志文件中，并更新检查点信息
- 当事务回滚时，Innodb会根据回滚日志中的信息，将数据恢复到修改前的状态，并释放相关资源
- 当系统崩溃时，Innodb会根据重做日志文件中的信息，将未完成的事务进行恢复或者回滚 。

### MySQL中的事务回滚机制概述？

MySQL中的事务回滚机制是指当事务执行过程中发生错误或者主动取消时，可以根据回滚日志将数据恢复到事务开始之前的状态。MySQL中有两种回滚方式：隐式回滚和显式回滚。

- 隐式回滚是指由于系统错误或者死锁等原因导致的自动回滚
- 显式回滚是指由用户发出的rollback命令导致的手动回滚

### 什么是锁？

锁是一种用于实现事务隔离性和并发控制的机制，可以防止多个事务同时对同一数据进行修改或读取

### 数据库的乐观锁和悲观锁是什么？

- 悲观锁：认为数据在处理过程中很可能会发生冲突，所以在操作数据之前就要加锁，防止其他事务对数据进行修改。悲观锁通常依赖于数据库提供的锁机制，如排他锁、共享锁等。

- 乐观锁：认为数据在处理过程中不太可能会发生冲突，所以在操作数据时不加锁，只在提交数据时检查是否有冲突。乐观锁通常需要自己实现，一般是通过版本号或时间戳来判断数据是否被修改过。

### innodb引擎中有哪几种锁？
- 共享锁和排他锁（Shared and Exclusive Locks）：这是最基本的行级锁，允许事务读取或修改一行。
- 意向锁（Intention Locks）：这是表级锁，表示事务以后需要对表中的某一行设置共享或排他锁。
- 记录锁（Record Locks）：这是对索引记录的锁定，防止其他事务修改或删除该记录。
- 间隙锁（Gap Locks）：这是对索引记录之间的间隙的锁定，防止其他事务在间隙中插入新的记录。
- 临键锁（Next-Key Locks）：这是记录锁和间隙锁的组合，防止幻影读。
- 插入意向锁（Insert Intention Locks）：这是插入操作在插入行之前设置的一种间隙锁，表示要插入的意图。
- AUTO-INC 锁（AUTO-INC Locks）：这是对自增列生成值时设置的一种特殊表级锁。
- 谓词锁（Predicate Locks for Spatial Indexes）：这是对空间索引中的最小边界矩形（MBR）值设置的一种锁，用于支持多维数据的隔离级别。

### 什么是死锁？怎么解决？
死锁是指两个或多个事务在执行过程中，因互相请求对方占用的资源而造成的一种僵局，导致事务无法继续执行。

例如，事务A持有资源X的锁，请求资源Y的锁；事务B持有资源Y的锁，请求资源X的锁；这样就形成了一个循环等待的死锁状态 

### 死锁怎么解决？

- 预防死锁：通过设置合理的锁粒度、锁顺序、超时时间等方式来避免死锁发生
- 检测死锁：通过监控工具或者日志来发现死锁，并及时处理
- 解除死锁：通过回滚或者杀死部分事务来释放锁资源，打破死锁状态

如果业务不好处理,可以用分布式事务锁或者使用乐观锁

### 锁的优化策略？
锁是用于保证并发事务之间数据一致性和隔离性的机制，但是过多或过长的锁等待也会影响数据库的性能和可用性。锁的优化策略有：
- 减少锁的粒度和范围，尽量使用行级锁而不是表级锁，尽量使用索引列作为查询条件，尽量缩短事务的执行时间和锁的持有时间。
- 减少锁的冲突和等待，尽量避免在高并发场景下对同一行或同一范围的数据进行修改或删除操作，尽量按照相同的顺序访问数据，尽量避免死锁的发生。
- 设置锁等待超时时间，当事务等待锁资源超过一定时间后，自动回滚，释放已经占有的锁资源。
- 使用死锁检测机制，当检测到死锁发生时，主动回滚其中一个或多个事务，打破死锁状态。
- 合理选择隔离级别和锁模式，根据业务需求和容忍度选择合适的隔离级别，例如读已提交（READ COMMITTED）或可重复读（REPEATABLE READ），根据访问类型选择合适的锁模式，例如共享锁或排他锁。
- 监控和分析锁相关的信息和状态，使用`show processlist`命令查看当前所有连接信息，使用`innodb_lock_wait_timeout`参数设置锁等待超时时间，使用`performance_schema或information_schema`库中的相关表或视图查看锁相关的统计信息和等待情况，使用`explain`命令分析查询语句的执行计划和锁策略。

### 什么是快照读和当前读？
快照读和当前读是 InnoDB 中两种不同的读取方式，区别在于：
- 快照读：指通过 MVCC 机制读取记录的某个历史版本，不需要加任何锁，也不会阻塞其他事务的修改操作。快照读只适用于普通的 `select` 语句
- 当前读：指直接读取记录的最新版本，需要加共享锁或者排他锁，会阻塞其他事务的修改操作。当前读适用于 `select ... for update`, `select ... lock in share mode`, `insert`, `update`, `delete` 等语句

### select for update有什么含义？
`select for update`是一种加锁查询，用于在读取数据时加上排他锁（exclusive lock），防止其他事务对数据进行修改。`select for update`通常用于实现悲观锁，即在操作数据之前就要加锁，避免并发冲突

### 隔离级别和锁的关系？

隔离级别是通过不同的锁机制来实现的，包括记录锁、间隙锁、临键锁、意向锁等。具体的锁机制和隔离级别之间的关系如下：
- 读未提交：不使用任何锁
- 读已提交：普通的`SELECT`语句使用快照读，不加锁；如果`SELECT`、`UPDATE`和`DELETE`已上锁，在**外键约束检查和重复键检查**时使用间隙锁或者临键锁，其他时候只使用记录锁
- 可重复读：普通的`SELECT`语句使用快照读，不加锁；如果`SELECT`、`UPDATE`和`DELETE`已上锁，在唯一索引上使用唯一查询条件时，只使用记录锁；在非唯一索引或者范围查询条件时，使用临键锁或者间隙锁，防止幻读
- 串行化：所有的`SELECT`语句都会被隐式转换为`SELECT … LOCK IN SHARE MODE`，加上共享锁。对所有的修改操作加排他锁，并在事务结束后释放

### 高并发下，如何做到安全的修改同一行数据？

- 使用悲观锁，即在修改数据之前加锁，阻止其他线程对同一行数据进行操作，直到修改完成后释放锁。这种方法可以保证数据的强一致性，但是会降低并发性能和可用性。
- 使用乐观锁，即在修改数据之前记录数据的版本号或时间戳，然后在修改时比较版本号或时间戳是否发生变化，如果没有变化则修改成功，否则修改失败。这种方法可以提高并发性能和可用性，但是会增加冲突和重试的可能性。
- 使用缓存队列，即将修改请求放入一个先进先出的缓存队列中，然后按顺序执行修改操作。这种方法可以避免冲突和重试，但是会增加内存消耗和响应延迟。