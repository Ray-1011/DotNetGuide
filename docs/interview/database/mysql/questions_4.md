---
title: MySQL面试题-索引
editLink: true
head:
  - - meta
    - name: description
      content: MySQL面试题，索引、索引底层原理、索引设计与优化
layout: doc
outline: deep
---
# MySQL面试题（索引篇）
## 索引
### 什么是索引？

索引是一种数据结构，它可以帮助数据库快速地查询、更新数据。索引可以提高查询效率，减少磁盘I/O操作，但也会增加维护成本，占用额外的存储空间。

### 索引的作用？
 - 加速查询：通过索引可以快速地定位到所需数据，避免全表扫描。
 - 保证数据唯一性：通过唯一索引可以保证表中每一行数据的唯一性。
 - 支持排序和分组：通过索引可以避免排序和分组操作产生的临时表。
 - 支持外键约束：通过索引可以加速外键的更新和删除操作，以及级联操作。

### 索引的优缺点？

优点：

 - 提高查询效率，降低数据库的IO成本
 - 提高数据的唯一性和完整性
 - 通过索引列对数据进行排序，降低数据的排序成本，降低了CPU的消耗

缺点：

 - 占用额外的存储空间，增加数据库的大小。
 - 降低更新效率，每次插入、删除、修改数据都需要维护索引。
 - 增加查询优化器的选择难度，可能导致走错索引或者不走索引。
 
### 索引的结构有哪些？
常见的MySQL索引结构有**B+Tree**、**Hash**、**Bitmap**、**R-Tree**等。

- B+Tree（多路平衡搜索树），它的特点是所有的叶子节点都在同一层，并且通过指针相连，非叶子节点只存储键值和指针，叶子节点存储键值和数据或指向数据的指针。B+树适合用于**范围查询和排序查询**
- Hash（哈希表）是一种以键值对为元素的数据结构，它通过哈希函数将键映射到一个位置，然后在该位置存储或查找对应的值。哈希表适合用于**等值查询**，但不适合用于范围查询和排序查询
- Bitmap（位图）是一种以位为单位来存储数据的数据结构，它通常用一个二进制位来表示某个元素是否存在或具有某种属性。位图适合用于存储稀疏的、离散的、单一属性的数据，可以有效地**节省空间和提高查询效率**
- R-Tree（R树）是一种类似于B-Tree 的树状结构，但是每个节点存储的是一个或多个空间对象（如矩形）的边界框和指针。R-Tree 索引适用于空间数据的查询，如地理位置、区域等

### 索引的分类？
索引的分类可以从多个维度进行分类，常见的分类方式有：

- 根据存储结构分类，常见的有B+树索引、哈希索引、位图索引等
- 根据所在位置分类，常见的有聚集索引（主键索引）和非聚集索引（辅助索引）
- 根据所包含列数分类，常见的有单列索引（简单索引）和多列索引（联合索引）
- 根据所包含内容分类，常见的有普通索引（无约束）、唯一索引（唯一约束）、全文索引（支持全文检索）、空间索引等

### 什么是聚集索引和非聚集索引

聚集索引是指以主键为键值构建的B+树索引，它的叶子节点存储的是整行数据，也就是数据文件本身。

非聚集索引是指以非主键为键值构建的B+树索引，它的叶子节点存储的是主键的值。

### 聚集和非聚集索引区别？

- 聚集索引可以直接定位到数据，不需要回表查询。非聚集索引需要先通过键值找到主键，然后再通过主键到聚集索引中查找数据，这个过程称为回表查询

- 聚集索引由于存储了整行数据，所以占用的空间比非聚集索引大，而且如果主键值变化，会导致数据移动。非聚集索引由于只存储了主键值，所以占用的空间比聚集索引小，而且如果非主键值变化，不会影响数据位置。

- 聚集索引由于按照主键顺序存储数据，所以对于范围查询和排序查询有优势，可以利用B+树的特性快速定位和遍历数据。非聚集索引由于按照非主键顺序存储数据，所以对于范围查询和排序查询没有优势，可能需要多次访问聚集索引或者额外的排序操作。

- 聚集索引由于是主键索引，所以一个表只能有一个聚集索引。非聚集索引可以有多个，可以根据不同的查询条件创建不同的非聚集索引³⁴⁵⁶。

聚集索引的优点是查询速度快，因为一次查找就可以找到所需数据。缺点是插入、删除、修改速度慢，因为需要移动数据来维持索引的顺序。

非聚集索引的优点是插入、删除、修改速度快，因为不需要移动数据，只需要更新索引即可。缺点是查询速度慢，因为需要两次查找，先查找索引再查找数据。

### 何时使用聚集索引与非聚集索引？
  
何时使用聚集索引与非聚集索引取决于具体的查询需求和性能考量。一般来说：

- 尽量选择区分度高、更新少、参与排序和范围查询的列作为主键，从而创建高效的聚集索引
- 尽量选择覆盖查询所需列的非聚集索引，从而避免回表查询

### 简单描述MySQL中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）-
  - 索引是一种数据结构，用于提高数据查询的效率。MySQL中常见的索引类型有B+树索引、哈希索引、全文索引等。不同类型的索引适用于不同的查询场景和数据类型 。
  - 主键是一种特殊的索引，用于保证表中每一行数据的唯一性和完整性。主键一般是聚簇索引，也就是按照主键值存储数据的物理顺序。主键可以提高基于主键的查询、排序和范围查询的效率，但是也会增加插入、更新和删除数据的开销 。
  - 唯一索引是一种特殊的索引，用于保证表中某一列或者多列的值的唯一性。唯一索引可以是聚簇索引或者非聚簇索引。唯一索引可以提高基于唯一列的查询、排序和范围查询的效率，但是也会增加插入、更新和删除数据的开销，并且需要额外的空间存储唯一列的值 。
  - 联合索引是一种特殊的索引，用于同时包含多个列作为键值的索引。联合索引可以是聚簇索引或者非聚簇索引。联合索引可以提高基于联合列的查询、排序和范围查询的效率，但是也会增加插入、更新和删除数据的开销，并且需要额外的空间存储联合列的值 。联合索引还需要遵循最左前缀原则，即查询条件必须包含联合列中最左边的列才能使用到联合索引 。
- 创建索引的原则
  - 创建索引的原则有以下几个：
    - 根据业务需求和查询频率创建合适类型和数量的索引，避免创建过多或者无用的索引，以免影响数据库性能和空间占用 。
    - 尽量选择区分度高、长度小、更新少、参与计算和排序的列作为索引列，以提高索引效率和命中率 。
    - 尽量创建覆盖查询所需列的索引，以避免回表查询或者额外的排序操作 。
    - 尽量避免在有空值或者重复值较多的列上创建索引，以减少无效扫描和空间浪费 。
    - 定期维护和优化索引，以避免索引碎片化和数据移动，保持索引的高效性 。

## 索引底层原理


### 索引为什么使用树结构

- 树结构可以**提高数据的查找、插入、删除、更新等操作的效率**，因为树结构可以利用分治思想和二分查找算法，可以将时间复杂度降低到O(logn)级别

- 树结构可以**减少磁盘IO次数**，因为树结构可以将数据分层存储，并且尽量保持每个节点都是满的或者半满的状态，从而减少磁盘页的数量和访问次数
    
- 树结构可以**方便地进行范围查询和排序操作**，因为树结构可以保持数据的有序性，只需要按照中序遍历的方式访问节点即可

- 树结构可以动态地调整和平衡，因为树结构可以通过分裂、合并、旋转等操作来维持树的高度和平衡性，从而**避免数据倾斜和热点问题**

### 索引的底层实现-
  - 不同类型的索引有不同的底层实现方式，这里以MySQL中最常用的B+树索引为例进行说明¹³。
    - MySQL中使用B+树作为默认的索引类型，它支持主键索引（聚集索引）和非主键索引（非聚集索引）两种形式¹³。
    - 主键索引是以主键为键值构建的B+树，它的叶子节点存储的是整行数据，也就是数据文件本身。主键索引可以直接定位到数据，不需要回表查询¹³。
    - 非主键索引是以非主键为键值构建的B+树，它的叶子节点存储的是主键的值。非主键索引需要先通过键值找到主键，然后再通过主键到主键索引中查找数据，这个过程称为回表查询¹³。
    - B+树索引的底层实现涉及到很多细节，例如如何分裂和合并节点，如何维护平衡性，如何利用缓冲池提高性能，如何加锁保证并发安全等，这里就不一一展开了，有兴趣的可以参考相关资料¹³。

### B树和B+树的区别

B树和B+树都是多路平衡查找树，区别在于：

B树的每个节点都存储了键值和对应的数据，而B+树的非叶子节点只存储了键值，数据都存储在叶子节点中。

B树的每个节点最多有m个子节点，而B+树的每个节点最多有m个子节点和m个键值。

B树的叶子节点之间没有任何关系，而B+树的叶子节点之间通过指针相连，形成一个有序链表。

B树可以在任意节点结束查找，而B+树只能在叶子节点结束查找。

### 为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引？

- B+树可以存储更多的键值，因为它的非叶子节点不存储数据，这样可以降低树的高度，提高查找效率。
- B+树可以支持范围查询和顺序访问，因为它的叶子节点之间通过指针相连，形成一个有序链表。而B树只能支持单点查询。
- B+树可以减少磁盘I/O次数，因为它只需要读取叶子节点就可以获取所有数据。而B树可能需要读取多个节点才能获取所需数据。

### B+Tree索引和Hash索引的区别

- MySQL中常用的索引树结构有B+树和哈希树两种。B+树是一种多路平衡搜索树，它的特点是非叶子节点只存储键值，叶子节点存储键值和数据或者指针，叶子节点之间用链表相连。B+树适用于等值查询和范围查询，但是不适用于模糊查询和多条件组合查询。哈希树是一种基于哈希函数的树形结构，它的特点是每个节点都有一个哈希值，根据哈希值来决定节点的位置和顺序。哈希树适用于等值查询，但是不适用于范围查询和排序操作

- 结构上，B+Tree索引是一种多层的树状结构，每个节点都包含若干个键值对，叶子节点存储数据或者数据的地址，非叶子节点存储索引键或者指向子节点的指针；Hash索引是一种基于哈希函数的结构，每个键值对都经过哈希函数计算出一个哈希值，然后根据哈希值存储在相应的桶中。
- 查询效率上，B+Tree索引对于范围查询和排序查询有较好的性能，因为它可以利用索引键的有序性和分层性进行快速定位和遍历；Hash索引对于等值查询有较好的性能，因为它可以利用哈希函数的唯一性和均匀性进行快速匹配和查找。
- 空间占用上，B+Tree索引通常占用较多的空间，因为它需要存储多层的节点和指针信息；Hash索引通常占用较少的空间，因为它只需要存储哈希值和数据地址信息。
- 冲突处理上，B+Tree索引通常不会出现冲突，因为它保证了索引键的唯一性和有序性；Hash索引可能会出现冲突，因为不同的键值对可能会计算出相同的哈希值，这时需要使用链表或者再哈希等方法来解决冲突。

## 索引设计与优化

### 如何创建和删除索引？

MySQL中常用的索引有：

- 主键索引（PRIMARY KEY）：用于加速查询操作，并保证索引列的值不重复且不为空
- 唯一索引（UNIQUE）：用于加速查询操作，并保证索引列的值不重复
- 普通索引（INDEX）：用于加速查询操作，没有任何限制
- 全文索引（FULLTEXT）：用于加速全文搜索操作，只适用于CHAR、VARCHAR和TEXT类型的列

常用的语法如下：

```sql
-- 在创建表时指定主键、唯一、普通、复合、全文类型的索引
CREATE TABLE table_name (
  column1 data_type,
  column2 data_type,
  column3 data_type,
  ...
  PRIMARY KEY (column1), -- 主键
  UNIQUE (column2), -- 唯一
  INDEX (column3), -- 普通
  INDEX (column4, column5), -- 复合
  FULLTEXT (column6) -- 全文
);

-- 在已有表上添加或删除主键、唯一、普通、组合、全文等类型的索引
ALTER TABLE table_name 
  ADD PRIMARY KEY (column1), -- 主键
  ADD UNIQUE (column2), -- 唯一
  ADD INDEX (column3), -- 普通
  ADD INDEX (column4, column5), -- 复合
  ADD FULLTEXT (column6), -- 全文
  DROP PRIMARY KEY, -- 删除主键
  DROP INDEX index_name; -- 删除其他类型的索引

-- 使用CREATE INDEX或DROP INDEX语句添加或删除普通、组合、全文等类型的索引
CREATE INDEX index_name ON table_name (column1); -- 普通
CREATE INDEX index_name ON table_name (column2, column3); -- 复合
CREATE FULLTEXT INDEX index_name ON table_name (column4); -- 全文
DROP INDEX index_name ON table_name; -- 删除其他类型的索引
```

还有一种是空间索引（SPATIAL），空间索引用于加速空间数据类型（GEOMETRY）的查询操作，只适用于MyISAM存储引擎

```sql
-- 创建索引
CREATE [index_type] INDEX index_name ON table_name (column1);
ALTER TABLE table_name ADD [index_type] INDEX index_name (column1);
-- 删除索引
DROP INDEX index_name ON table_name;
ALTER TABLE table_name DROP INDEX index_name;
```

### 如何看到某个表的所有索引？

- `SHOW INDEX`：使用SHOW INDEX，如`SHOW INDEX FROM table_name;`
- `information_schema.statistics`：使用information_schema.statistics，如`SELECT * FROM information_schema.statistics WHERE table_name = 'table_name';`

以上两个命令会返回table中每个索引的相关信息，包括索引名、列名、是否唯一、是否主键、是否空值、索引类型、基数等。

### 怎么查询SQL语句是否使用了索引？
通常使用`EXPLAIN`命令或者`MySQLslap`工具来分析。如：

```sql
explain select * from table where name='zhangsan'
```

但在具体的操作中也可以配合其他命令使索引满足需求，可以使用

- `SHOW INDEX`命令或者`MySQLshow`工具来查看表中已经存在的索引信息，包括索引名称、类型、列、基数等
- `SHOW STATUS`命令或者`MySQLadmin status`工具来查看数据库运行状态中与索引相关的参数或指标，如`Handler_read_key`、`Handler_read_next`等
- `SHOW PROFILE`命令或者`MySQLadmin profile`工具来查看查询语句执行过程中各个阶段所消耗的时间和资源，如`Creating index`、`Using index`等


### 什么是索引覆盖？

**索引覆盖**是指一个索引包含了查询所需的所有列，无需再回表查询其他列的情况。**索引覆盖**可以提高查询性能，减少IO操作和锁竞争。在创建联合索引时，可以考虑将经常查询的列放在索引中，以实现**索引覆盖**的效果。

### 什么是回表？

回表：在MySQL中使用非聚集索引（也称为二级索引、普通索引或辅助索引）查询数据时，需要先通过非聚集索引找到主键的值，然后再通过主键到聚集索引（也称为主键索引）中查找完整的记录的过程。

回表的原因：MySQL中的非聚集索引的叶子节点只存储了主键的值，而不是整行数据，所以如果查询的列不完全包含在非聚集索引中，就需要再次访问聚集索引来获取所需的数据。

回表会增加查询的开销，因为需要扫描两次B+树，并且可能导致随机IO。为了避免回表，可以使用**索引覆盖**，即让查询的列都包含在非聚集索引中，这样就可以直接从非聚集索引获取所需的数据，不需要再访问聚集索引

### 什么是索引下推？

索引下推是指在使用联合索引时，将部分过滤条件下推到索引层进行过滤，而不是在回表后再过滤的优化技术。索引下推可以减少回表的次数和数据量，提高查询性能。在MySQL 5.6 及以上版本中，支持自动进行索引下推优化

### 非聚集索引一定会回表查询吗？

不一定。如果查询的列都包含在非聚集索引中，那么就不需要回表查询，这种情况称为**索引覆盖**

例如，如果有一个非聚集索引是以name为键值构建的，那么执行`select id,name from user where name = 'zhangsan'`就不需要回表查询，因为通过非聚集索引已经能获取到id和name的值

如果查询的列不完全包含在非聚集索引中，那么就需要回表查询，这种情况称为**二次查找**。例如，如果有一个非聚集索引是以age为键值构建的，那么执行`select * from user where age = 30`就需要回表查询，因为通过非聚集索引只能获取到主键的值，然后再通过主键到聚集索引中查找完整的记录

### 非主键索引一定会查询多次吗？

不一定。如果使用的是**索引覆盖**，那么只需要查询一次非主键索引即可获取所需的数据。如果使用的是二次查找，那么需要先查询一次非主键索引获取主键值，再查询一次主键索引获取完整的记录。

### 什么是最左前缀原则？

最左前缀原则是指在使用联合索引时，查询条件必须包含索引列从左到右的最左部分，才能保证索引有效。例如，如果有一个联合索引(a,b,c)，那么查询条件可以是a或者a和b或者a和b和c，但不能是b或者c或者b和c

### 索引创建（设计）原则？

索引创建时应该考虑以下几点：

- 根据查询频率和过滤效果来选择需要创建索引的列，一般来说，经常作为查询条件并且能够明显减少扫描行数的列适合创建索引
- 在唯一性约束和主键约束的列上创建索引，可以加速数据的插入、修改和删除操作
- 尽量选择区分度高的列作为索引，区分度越高，重复的键值越少，查询效率越高
- 在多个列上创建联合索引时，应该考虑列的顺序和使用频率，把最常用和最有区分度的列放在最前面
- 尽量创建符合最左前缀原则的联合索引，即查询条件要匹配联合索引中从左到右的连续字段。这样可以提高索引的复用率和覆盖率

索引创建时应该避免以下几点：

- 尽量避免创建过多的索引，因为索引会占用额外的存储空间，并且会增加插入、更新、删除操作的开销。一般来说，单张表的索引数不宜超过5个
- 尽量避免在频繁更新的列上创建索引，因为每次更新都会导致索引的维护，影响性能
- 尽量避免在数据类型为文本、图片等大字段上创建索引，因为这些字段的索引会占用大量的空间，并且降低查询效率
- 尽量避免在在数据量小或值分布不均匀的列上避免创建，因为这样的索引很难发挥作用，反而会增加维护成本
- 尽量避免在经常进行计算、函数操作或类型转换的列上创建，因为这样会导致索引失效，无法使用

### 适合建立索引的列？

- 经常作为**查询条件或排序条件**的列，如主键、外键、状态、日期等。
- 经常参与**连接操作**的列，如关联表中的公共列。
- 数据量大且分布均匀的列，分布均匀意味着如身份证号、手机号等。
- 数据类型简单且长度固定的列，如整型、日期型等。
- 经常**根据范围**进行搜索的列，因为索引已经排序，其指定的范围是连续的；

### 不适合建立索引的列？

- 经常修改或删除的列，如计数器、标志位等。
- 数据量小或分布不均匀的列，如性别、颜色等。
- 数据类型复杂或长度不固定的列，如文本、二进制等。

### 索引怎么设计 (优化)

- 选择合适的存储结构和位置。B+树索引适合范围查询和排序，哈希索引适合精确匹配查询，位图索引适合低基数列查询。聚集索引适合频繁访问的主键列，非聚集索引适合辅助查询的非主键列。
- 选择合适的列数和顺序。单列索引适合单条件查询，多列索引适合多条件查询。多列索引的顺序应该遵循最左前缀原则，即按照查询条件的出现频率和区分度从高到低排列。
- 选择合适的内容和长度。应该尽量避免在大字段、重复字段、空值字段上创建索引，因为这些字段的索引效果不佳，反而会浪费空间和时间。另外，应该尽量缩短索引的长度，比如使用前缀索引、压缩索引等，以减少索引的占用空间和维护开销。
- 定期检查和维护索引。应该定期使用工具或命令检查索引的使用情况和效果，比如使用`EXPLAIN`分析执行计划，使用`SHOW INDEX`查看索引信息等。另外，应该定期使用工具或命令维护索引的状态和性能，比如使用`OPTIMIZE TABLE`优化表结构，使用`ANALYZE TABLE`更新表统计信息等

### 索引失效的情况？
这里举一些常见例子，如：

- 索引列的类型和查询条件的类型不一致，导致隐式转换
- 索引列的顺序和联合索引的顺序不一致，导致无法利用最左前缀原则
- 查询条件中使用了OR连接符，导致无法同时匹配多个索引列，如果要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引
- `where` 子句里对索引列上有数学运算，用不上索引
- `where` 子句里对有索引列使用函数，用不上索引
- 使用不等于（`<>`）或者范围查询（`between ... and ...`）等操作符，导致无法使用后续的联合索引
- `like` 查询是以 `%` 开头，导致无法使用前缀索引

### 索引不适合哪些场景

- 表的数据量很小，或者查询的结果集很大，这时候使用索引反而会增加查询的开销，因为需要多次访问索引和数据文件，而全表扫描可能更快
- 表的数据频繁变化，这时候使用索引会增加维护的成本，因为每次数据变化都需要更新索引，而且可能导致索引碎片化和数据移动
- 查询的条件是复杂的表达式或者函数，这时候使用索引会失效，因为无法利用索引的有序性和范围性，而且可能导致全表扫描

### 列值为NULL时，查询是否会用到索引？

- 查询条件是`is NULL`或者`is not NULL`，那么可以使用到索引，前提是该列上有普通索引或者唯一索引
- 查询条件是`= NULL`或者`<> NULL`，无法使用到索引，因为这样的查询永远返回空结果集，因为**NULL值无法和任何值相等或者不等**
- 查询条件是`< null`或者`> null`，无法使用到索引，因为这样的查询也永远返回空结果集，因为**NULL值无法和任何值进行比较**
- 如果查询条件是组合条件，例如`a = 1 and b = null`，可以使用到a列上的索引，但是无法使用到b列上的索引，因为b列的条件无效