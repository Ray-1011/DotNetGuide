---
outline: deep
---

# 数据库通用面试题（一）
## 基础概念
### 非关系型数据库和关系型数据库的区别

 - 关系型数据库通常以二维表格的形式存储数据，适合处理结构化、事务性、一致性要求高的数据。
 - 非关系型数据库通常以键值对、文档、图等形式存储数据，适合处理海量、非结构化、分布式的数据。

### 非关系型数据库和关系型数据库的优势比较
关系型数据库的优势：

- 易于理解，二维表格的结构非常贴近逻辑和现实世界
- 使用方便，支持通用的SQL语言来进行复杂的查询和操作
- 易于维护，保证了数据的ACID属性，避免了数据冗余和不一致的问题
- 支持事务处理，可以确保数据的完整性和安全性

非关系型数据库的优势：

- 格式灵活，可以存储多种类型的数据，不需要预先定义表结构
- 性能高效，可以直接根据键值对进行查询，不需要经过SQL层的解析
- 可扩展性强，可以通过集群来实现负载均衡和水平扩展
- 成本低廉，大部分非关系型数据库是开源的，部署简单

### 视图是什么？
视图是一种虚拟的表，它是由一条或多条SQL语句定义出来的结果集。视图不存储实际的数据，而是在查询时动态生成。视图可以简化复杂的查询，保护数据的安全性，提高数据的独立性。

### 游标是什么？

游标是一种用于操作结果集中每一行数据的机制。游标可以将结果集中的每一行分开处理，并且可以随时修改或删除。游标通常用于需要逐行处理数据的情况。

### 视图的优缺点有哪些？

视图的优点有：

- 简化复杂的查询，提高可读性和易用性
- 保护数据的安全性，只暴露需要的数据给用户
- 提高数据的独立性，对视图的修改不影响基础表

视图的缺点有：

- 降低查询效率，因为每次查询都要重新生成结果集
- 增加维护成本，因为视图依赖于基础表，如果基础表发生变化，则需要修改视图
- 限制了对数据的操作能力，因为并不是所有视图都支持更新、插入或删除操作

### 主键、外键、超键、候选键是什么？

超键是能唯一标识表中每一行记录的属性或属性组合。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键需包含主键和候选键。

主键是能够唯一标识表中每一行记录的属性或属性组合。主键不能重复且不能为空。

外键是一种能够引用另一个表中主键或候选键的属性或属性组合。外键可以重复且可以为空。

候选键是一种能够最小化地唯一标识表中每一行记录的属性或属性组合。候选键是超键去掉多余属性后得到的最小超键。

### 触发器的作用是什么？

触发器是一种特殊类型的存储过程，它会在某个事件发生时自动执行。触发器通常用于实现以下功能：

- 数据完整性检查，在插入、更新或删除操作前后验证数据是否符合规则
- 数据审计跟踪，在插入、更新或删除操作前后记录操作日志或历史信息
- 数据同步更新，在插入、更新或删除操作前后同步更新其他相关表中的数据

### 什么是存储过程？
存储过程是一组预先编译好并保存在数据库中的SQL语句集合。存储过程可以接收参数并返回结果。存储过程通常用于实现以下功能：

- 封装复杂逻辑，在数据库端执行而不需要在客户端传输大量SQL语句
- 提高性能，在第一次执行时编译并缓存执行计划，在后续执行时直接调用而不需要重新编译
- 增强安全性，在存储过程中控制对数据和对象的访问权限

### 存储过程如何调用？
存储过程可以通过以下方式来调用：

- 在SQL命令行中使用EXEC或CALL命令来调用
- 在其他SQL语句中使用EXECUTE AS子句来调用
- 在应用程序代码中使用相应语言提供的API来调用

### 存储过程的优缺点？

优点：

 - 提高性能，因为存储过程只编译一次，而且可以缓存在内存中，减少网络传输和解析开销。
 - 提高安全性，因为存储过程可以控制用户对数据的访问权限，避免SQL注入攻击。
 - 提高可维护性，因为存储过程可以封装复杂的业务逻辑，方便修改和重用。

缺点：

- 增加开发和调试难度，因为存储过程需要使用特定的语言和工具，而且错误信息不容易获取。
- 降低可移植性，因为存储过程依赖于数据库的类型和版本，不同的数据库可能有不同的语法和功能。
- 增加测试和维护成本，因为存储过程需要单独测试和更新，而且可能影响其他应用程序的运行

### 存储过程与函数的区别

存储过程是一组预定义的SQL语句，可以执行一些复杂的逻辑操作，可以有输入参数和输出参数，但不能有返回值；

函数是一种特殊的存储过程，可以执行一些简单的计算或转换操作，必须有输入参数和返回值，但不能有输出参数。

 - 存储过程可以使用控制语句，如IF、WHILE、LOOP等，来实现流程控制；函数不能使用控制语句，只能使用表达式和运算符。
 - 存储过程可以对数据库进行增删改查等操作；函数只能进行查询操作，不能修改数据库的状态。
 - 存储过程可以调用函数；函数不能调用存储过程。

### 什么是临时表，临时表什么时候删除?
临时表是一种特殊的表，它只在当前会话或当前事务中可见，用于存储一些临时的数据或中间结果。
临时表有两种类型：
 - 隐式临时表和显式临时表。隐式临时表是由系统自动创建和删除的，例如在执行某些复杂的查询时；
 - 显式临时表是由用户手动创建和删除的，使用`CREATE TEMPORARY TABLE语句`。

隐式临时表在查询结束后自动删除；显式临时表在当前会话结束或主动使用`DROP TEMPORARY TABLE`语句删除时删除。

  - 临时表是一种特殊的表，它只在当前会话或当前事务中可见，用于存储临时数据。
  - 临时表有两种类型：隐式临时表和显式临时表。
    - 隐式临时表是由系统自动创建和删除的，例如在执行某些复杂查询时，系统会将中间结果存放在隐式临时表中。隐式临时表通常存储在内存中，如果内存不足，则会转移到磁盘上。隐式临时表在查询结束后自动删除。
    - 显式临时表是由用户手动创建和删除的，使用CREATE TEMPORARY TABLE语句创建。显式临时表可以存储在内存中或磁盘上，取决于表的类型和大小。显式临时表在当前会话结束或手动删除后自动删除。

### 什么是数据库范式？
数据库范式的级别为：

 - 第一范式（1NF）：要求每个属性都是不可分割的原子值，并且每个记录都是唯一的
 - 第二范式（2NF）：要求满足1NF，并且每个非主属性都完全依赖于主键（消除部分依赖）
 - 第三范式（3NF）：要求满足2NF，并且每个非主属性都不传递依赖于主键（消除传递依赖）
 - BC范式（BCNF）：要求满足3NF，并且每个决定因素都是候选键（消除主属性对非主属性的决定）
 - 第四范式（4NF）：要求满足BCNF，并且没有多值依赖（消除非平凡的多值依赖）
 - 第五范式（5NF）：要求满足4NF，并且没有连接依赖（消除非平凡的连接依赖）

一般，数据库设计符合3NF或BCNF就可以了。

### 什么是反范式？

反范式是指在满足一定范式级别的基础上，适当地增加数据冗余和重复，以提高查询效率和简化查询语句。反范式通常用于数据仓库或分析型数据库中，对于经常变化或需要事务处理的数据不适合使用。

### 范式和反范式优缺点？

优点：
 - 范式的优点是可以节省存储空间，保证数据一致性和完整性，方便数据维护和更新
 - 反范式的优点是可以减少表的数量和连接操作，提高查询性能和简化查询语句

缺点：
 - 范式的缺点是可能增加表的数量和连接操作，影响查询性能和复杂度
 - 反范式的缺点是可能浪费存储空间，造成数据不一致性和冗余管理问题

### 什么是 内连接、外连接、交叉连接、笛卡尔积等?
- 内连接（inner join）是指只返回两个表中匹配的行，也就是说，只有满足连接条件的行才会被返回。
- 外连接（outer join）是指除了返回两个表中匹配的行之外，还返回其中一个或两个表中不匹配的行。外连接分为左外连接（left outer join），右外连接（right outer join）和全外连接（full outer join）。
    - 左外连接是指返回左表中所有的行，以及右表中与之匹配的行；
    - 右外连接是指返回右表中所有的行，以及左表中与之匹配的行；
    - 全外连接是指返回两个表中所有的行，无论是否匹配。
- 交叉连接（cross join）是指返回两个表中所有可能的组合，也就是说，每个左表中的行都与右表中的每个行进行组合。交叉连接也可以看作是没有条件的内连接。
- 笛卡尔积（cartesian product）是指两个集合中所有可能的有序对组成的集合。在数据库中，如果两个表进行交叉连接，那么它们的结果集就是它们各自行数的乘积，也就是它们的笛卡尔积。

### 什么是子查询？

子查询是一种嵌套在其他SQL语句中的查询，用于为主查询返回其所需数据或者对检索数据进行进一步的限制。子查询可以在`SELECT`、`INSERT`、`UPDATE`和`DELETE`语句中，同`=`、`<`、`>`、`>=`、`<=`、`IN`、`BETWEEN`等运算符一起使用。子查询必须括在圆括号中，并且通常在主查询之前执行

### SQL语言分类

 - 数据定义语言（DDL）：用于定义数据库对象，如表、视图、索引等。常用的DDL语句有CREATE、ALTER、DROP等
 - 数据操作语言（DML）：用于对数据库中的数据进行增删改查。常用的DML语句有INSERT、DELETE、UPDATE、SELECT等
 - 数据控制语言（DCL）：用于控制数据库的访问权限和事务处理等。常用的DCL语句有GRANT，REVOKE，COMMIT，ROLLBACK等
 - 数据查询语言（DQL），用于从数据库中查询数据。DQL通常被认为是DML的一个子集，因为它只涉及SELECT语句

## SQL语句

### SQL注入漏洞是什么？

SQL注入漏洞是指攻击者通过构造恶意的SQL语句，利用Web应用程序对数据库的访问权限，执行非法的数据库操作，从而获取敏感信息或破坏数据完整性的攻击方式。

### SQL注入漏洞如何防止？

- 使用预编译语句或参数化查询，避免用户输入直接拼接到SQL语句中，而是通过占位符和参数绑定的方式传递给数据库。
- 对用户输入进行严格的验证和过滤，删除或转义可能引起SQL语句混淆的特殊字符，如单引号、分号、注释符等。
- 对数据库访问权限进行最小化原则，根据不同的用户角色和业务需求，分配合适的数据库权限，禁止执行敏感的数据库操作。
- 对错误信息进行屏蔽和处理，不向用户暴露数据库的具体错误信息，而是使用自定义的错误页面或日志记录。


### SQL的执行顺序是什么？
SQL的执行顺序是指数据库在处理SQL语句时，按照一定的规则和顺序对各个子句进行解析和执行的过程。一般来说，SQL的执行顺序是：

- FROM：确定数据来源，包括表、视图、子查询等。
- ON：根据连接条件过滤FROM中的数据。
- JOIN：根据连接类型（内连接、外连接等）合并数据。
- WHERE：根据过滤条件筛选数据。
- GROUP BY：根据分组字段对数据进行分组。
- HAVING：根据分组后的过滤条件筛选分组。
- SELECT：确定输出的列和表达式。
- DISTINCT：去除重复的行。
- ORDER BY：根据排序规则对数据进行排序。
- LIMIT：限制输出的行数。

例如，执行下面的查询语句：

```sql
SELECT name, AVG(score) average FROM students s JOIN scores sc ON s.id = sc.student_id WHERE gender = 'M' GROUP BY name HAVING average > 80 ORDER BY average DESC LIMIT 3;
```

SQL引擎会按照以下顺序执行：

- 从students表和scores表中取出所有数据行，根据ON条件进行内连接。
- 根据WHERE条件，只保留gender为'M'的数据行。
- 根据GROUP BY条件，按照name进行分组，计算每组的AVG(score)值。
- 根据HAVING条件，只保留average大于80的分组。
- 根据SELECT条件，输出name和average两列。
- 根据DISTINCT条件，去除重复的行。（本例中没有使用DISTINCT）
- 根据ORDER BY条件，按照average降序排序输出结果。
- 根据LIMIT条件，只输出前3条记录。

> 需要注意的是，这个执行顺序并不一定等同于SQL语句的书写顺序，也不一定等同于数据库实际执行的顺序，因为数据库可能会根据优化器的策略对SQL语句进行重写或者调整。


### varchar和char的使用场景?

- varchar是可变长字符串类型，它只占用实际长度所需的空间，并在末尾添加一个结束符，如果字符串长度不确定或者差异很大，则使用varchar类型
- char是定长字符串类型，它总是占用指定长度所需的空间，并在不足时用空格填充，如果字符串长度固定或者差异很小，则使用char类型

### in和exists的区别

in和exists都是用来判断一个值是否在一个子查询的结果集中。区别在于：

- in是一个比较操作符，它会把左边的值和右边的子查询结果集逐一比较，如果存在相等的值，就返回true，否则返回false。in适合于子查询结果集较小，而外层查询结果集较大的情况。
- exists是一个逻辑操作符，它只判断子查询是否返回至少一行数据，如果是，就返回true，否则返回false。exists通常和相关子查询配合使用，相关子查询指的是子查询中引用了外层查询的字段。exists适合于子查询结果集较大，而外层查询结果集较小的情况。
- in和exists的执行效率不同。in会先执行子查询，然后将结果集保存在临时表中，再与外层查询的值进行比较。exists则是先执行外层查询，然后用每一行的结果去执行子查询，直到找到满足条件的记录或者遍历完所有记录为止。因此，当子查询结果集较大时，in的效率会下降，而exists的效率会提高。

### drop、truncate、 delete区别？

drop、truncate、delete都可以用来删除表中的数据，但它们有以下区别：

| 操作 | 说明 | 是否可以恢复 | 是否支持事务 | 是否触发触发器 | 是否重置自增值 |
| --- | ---- | ---------- | ---------- | ------------ | ------------ |
| drop | 删除整个表，包括表结构、数据、索引、约束等 | 否 | 否 | 否 | 是 |
| truncate | 清空表中的所有数据，保留表结构、索引、约束等 | 否 | 否 | 否 | 是 |
| delete | 删除表中的部分或全部数据，可以添加where条件进行筛选 | 是 | 是 | 是 | 否 |

### like的 % 和 _ 的区别?

- `%`是一个通配符，用来表示任意长度（包括0）的任意字符，可以放在模式的开头、结尾或中间
- `_`是一个通配符，用来表示任意单个字符，可以放在模式的任意位置。

例如：

查询名字以a开头的记录，可以使用`WHERE name LIKE 'a%'`

查询名字包含b的记录，可以使用`WHERE name LIKE '%b%'`

查询名字长度为3的记录，可以使用`WHERE name LIKE '___'`

### count(*)、count(1)、count(column)的区别

 - count(*)：表示统计表中所有记录数，包括**NULL值**和重复值。它会扫描整张表，返回一个精确的值。
 - count(1)：表示统计表中所有**非NULL值**的记录数，包括重复值。它会忽略所有列，只看行数，返回一个精确的值。
 - count(column)：表示统计表中指定列**非NULL值**的记录数，包括重复值。它会扫描指定列，过滤掉NULL值，返回一个精确的值。


